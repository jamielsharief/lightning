{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Lightning A set of lightweight components that can be used together or seperatley.","title":"Lightning"},{"location":"#lightning","text":"A set of lightweight components that can be used together or seperatley.","title":"Lightning"},{"location":"autoloader/","text":"PSR-4 Autoloader A lightweight PSR-4 Autoloader. Usage Create the Autoloader instance pointing to the project root and then add the namespaces which you want it to resolve then call register . $autoloader = new Autoloader(dirname(__DIR__)); $autoloader->addNamespaces([ 'App' => 'app', 'Lightning' => 'src', 'Lightning\\\\Test' => 'tests' ]); $autoloader->register();","title":"Autoloader"},{"location":"autoloader/#psr-4-autoloader","text":"A lightweight PSR-4 Autoloader.","title":"PSR-4 Autoloader"},{"location":"autoloader/#usage","text":"Create the Autoloader instance pointing to the project root and then add the namespaces which you want it to resolve then call register . $autoloader = new Autoloader(dirname(__DIR__)); $autoloader->addNamespaces([ 'App' => 'app', 'Lightning' => 'src', 'Lightning\\\\Test' => 'tests' ]); $autoloader->register();","title":"Usage"},{"location":"autowire/","text":"Autowire You can create the Autowire class with or without a PSR-11 Container. $autowire = new Autowire() $autowire = new Autowire($diContainer); You can autowire a class, a method of an object or a closure $object = $autowire->class(ArticlesController::class); $response = $autowire->method($object, 'index'); // you can also pass a 3rd argument for additional params $result = $autowire->function(function(Session $session){ return $session->get('foo'); });","title":"Autowire"},{"location":"autowire/#autowire","text":"You can create the Autowire class with or without a PSR-11 Container. $autowire = new Autowire() $autowire = new Autowire($diContainer); You can autowire a class, a method of an object or a closure $object = $autowire->class(ArticlesController::class); $response = $autowire->method($object, 'index'); // you can also pass a 3rd argument for additional params $result = $autowire->function(function(Session $session){ return $session->get('foo'); });","title":"Autowire"},{"location":"cache/","text":"PSR-16 Cache Simple lightweight PSR cache libraries, File , Redis , Apcu and Memory . Usage Create the Cache object $cache = new FileCache(__DIR__ '/tmp/cache'); // to set $cache->set('foo','bar'); // check if the value is in cache $bool = $cache->has('foo'); // gets a value from the cache $result = $cache->get('foo'); // deletes a value from the cache $cache->delete('foo'); // clears the cache $cache->clear(); Other CacheInterface methods include getMultiple , setMultiple and deleteMultiple . File Cache To create a new File cache object simple pass the directory where data will be cached. $cache = new FileCache(__DIR__ '/tmp/cache'); Redis Cache To use the Redis cache you will need to have the PHP extension php-redis installed and a Redis server setup. $connection = new Redis; $connection->pconnect('127.0.0.1', 6379); $cache = new RedisCache($connection); Apcu Cache To use Apcu you need to have the Apcu extension installed with apc.enbabled and apc.enable_cli in your php.ini files. Then to create a Apcu cache object, you will need to have $cache = new ApcuCache(); Memory Cache The memory cache is ideal for testing or to just cache during during the request. $cache = new MemoryCache();","title":"Cache"},{"location":"cache/#psr-16-cache","text":"Simple lightweight PSR cache libraries, File , Redis , Apcu and Memory .","title":"PSR-16 Cache"},{"location":"cache/#usage","text":"Create the Cache object $cache = new FileCache(__DIR__ '/tmp/cache'); // to set $cache->set('foo','bar'); // check if the value is in cache $bool = $cache->has('foo'); // gets a value from the cache $result = $cache->get('foo'); // deletes a value from the cache $cache->delete('foo'); // clears the cache $cache->clear(); Other CacheInterface methods include getMultiple , setMultiple and deleteMultiple .","title":"Usage"},{"location":"cache/#file-cache","text":"To create a new File cache object simple pass the directory where data will be cached. $cache = new FileCache(__DIR__ '/tmp/cache');","title":"File Cache"},{"location":"cache/#redis-cache","text":"To use the Redis cache you will need to have the PHP extension php-redis installed and a Redis server setup. $connection = new Redis; $connection->pconnect('127.0.0.1', 6379); $cache = new RedisCache($connection);","title":"Redis Cache"},{"location":"cache/#apcu-cache","text":"To use Apcu you need to have the Apcu extension installed with apc.enbabled and apc.enable_cli in your php.ini files. Then to create a Apcu cache object, you will need to have $cache = new ApcuCache();","title":"Apcu Cache"},{"location":"cache/#memory-cache","text":"The memory cache is ideal for testing or to just cache during during the request. $cache = new MemoryCache();","title":"Memory Cache"},{"location":"console/","text":"Console The console component is to make console utilities and applications, there is no plan for a command runner. Command Create a Command in your app\\Command folder. <?php declare(strict_types=1); namespace App\\Command; use Lightning\\Console\\Arguments; use Lightning\\Console\\ConsoleIo; use Lightning\\Console\\AbstractCommand as Command; class HelloWorldCommand extends Command { protected string $name = 'hello'; protected string $description = 'hello world command'; protected function initialize(): void { $this->addArgument('name', [ 'description' => 'name to use', 'default' => 'world' ]); } protected function execute(Arguments $args, ConsoleIo $io): int { $this->out(sprintf('Hello <yellow>%s</yellow>!', $args->getArgument('name'))); return self::SUCCESS; } } Console Application To create a Console Application #!/usr/bin/env php <?php use Lightning\\Console\\ConsoleIo; use function Lightning\\Dotenv\\env; use Lightning\\Migration\\Migration; use Lightning\\Console\\ConsoleApplication; use Lightning\\Console\\ConsoleArgumentParser; use Lightning\\Migration\\Command\\MigrateUpCommand; use Lightning\\Migration\\Command\\MigrateDownCommand; include dirname(__DIR__) . '/config/bootstrap_cli.php'; $io = new ConsoleIo(); $pdo = new PDO(env('DB_URL'), env('DB_USERNAME'), env('DB_PASSWORD')); $migration = new Migration($pdo, dirname(__DIR__) . '/database/migrations'); $parser = new ConsoleArgumentParser(); $application = new ConsoleApplication($io); $application->setName('migrate') ->setDescription('Database migration'); $application->add(new MigrateUpCommand($parser, $io, $migration)); $application->add(new MigrateDownCommand($parser, $io, $migration)); exit($application->run($argv)); ConsoleIO The ConsoleIO object for input and output. $io->out('hello'); // to stdout $io->err('opps'); // to stderr $io->nl(); // new line $io->hr(); // horiziontal rule Inputs $name = $io->ask(); $continue = $io->ask('Continue ?','n'); // adds a default $continue = $io->askChoice('Continue ? (name)',['y','n']); Alerts Display alerts to users, warning and error will be displayed stderr . $io->info('INFO', 'This an info alert'); $io->success('SUCCESS', 'This is a success alert'); $io->warning('WARNING', 'This is a warning alert'); $io->error('ERROR', 'This an error alert'); Progress Bar Display a progress bar to user $io->progressBar(50, 100); Status Often when running commands you are carrying out multiple tasks, and its nice to show these to the user. This is where the status method comes in handy, statuses are setup for ok , warning and error . $io->status('ok', 'Delete file'); $io->status('warning', 'Directory is writable'); $io->status('error', 'Create directory'); You can also add your own status $io->setStatus('skipped','blue'); $io->setStatus('ignored','yellow'); Testing Create your PHP test file and add the ConsoleIntegrationTestTrait , then create the Command object using the TestConsoleIo and call the setupIntegrationTesting function. <?php declare(strict_types=1); namespace App\\Command; use PHPUnit\\Framework\\TestCase; use Lightning\\Console\\TestSuite\\ConsoleIntegrationTestTrait; final class HelloWordCommandTest extends TestCase { use ConsoleIntegrationTestTrait; public function setUp(): void { $command = new HelloWorldCommand(new ConsoleArgumentParser(), new TestConsoleIo()); $this->setupIntegrationTesting($command); } public function testExitSuccesss(): void { $this->execute(); $this->assertExitSuccess(); $this->assertOutputContains('Hello world!'); } } To execute the Command with arguments $this->execute(['--bold','jon']); If your command asks for input from the user, you can pass the input in the execute method $this->execute([],['jon']); Assertion methods $this->assertExitSuccess(); $this->assertExitError(); $this->assertExitCode(3); // stdout $this->assertOutputContains('x'); $this->assertOutputNotContains('x'); $this->assertOutputEmpty(); $this->assertOutputNotEmpty(); $this->assertOutputMatchesRegularExpression('/foo/'); $this->assertOutputDoesNotMatchRegularExpression('/foo/'); // stderr $this->assertErrorContains('x'); $this->assertErrorNotContains('x'); $this->assertErrorEmpty(); $this->assertErrorNotEmpty(); $this->assertErrorMatchesRegularExpression('/foo/'); $this->assertErrorDoesNotMatchRegularExpression('/foo/');","title":"Console"},{"location":"console/#console","text":"The console component is to make console utilities and applications, there is no plan for a command runner.","title":"Console"},{"location":"console/#command","text":"Create a Command in your app\\Command folder. <?php declare(strict_types=1); namespace App\\Command; use Lightning\\Console\\Arguments; use Lightning\\Console\\ConsoleIo; use Lightning\\Console\\AbstractCommand as Command; class HelloWorldCommand extends Command { protected string $name = 'hello'; protected string $description = 'hello world command'; protected function initialize(): void { $this->addArgument('name', [ 'description' => 'name to use', 'default' => 'world' ]); } protected function execute(Arguments $args, ConsoleIo $io): int { $this->out(sprintf('Hello <yellow>%s</yellow>!', $args->getArgument('name'))); return self::SUCCESS; } }","title":"Command"},{"location":"console/#console-application","text":"To create a Console Application #!/usr/bin/env php <?php use Lightning\\Console\\ConsoleIo; use function Lightning\\Dotenv\\env; use Lightning\\Migration\\Migration; use Lightning\\Console\\ConsoleApplication; use Lightning\\Console\\ConsoleArgumentParser; use Lightning\\Migration\\Command\\MigrateUpCommand; use Lightning\\Migration\\Command\\MigrateDownCommand; include dirname(__DIR__) . '/config/bootstrap_cli.php'; $io = new ConsoleIo(); $pdo = new PDO(env('DB_URL'), env('DB_USERNAME'), env('DB_PASSWORD')); $migration = new Migration($pdo, dirname(__DIR__) . '/database/migrations'); $parser = new ConsoleArgumentParser(); $application = new ConsoleApplication($io); $application->setName('migrate') ->setDescription('Database migration'); $application->add(new MigrateUpCommand($parser, $io, $migration)); $application->add(new MigrateDownCommand($parser, $io, $migration)); exit($application->run($argv));","title":"Console Application"},{"location":"console/#consoleio","text":"The ConsoleIO object for input and output. $io->out('hello'); // to stdout $io->err('opps'); // to stderr $io->nl(); // new line $io->hr(); // horiziontal rule","title":"ConsoleIO"},{"location":"console/#inputs","text":"$name = $io->ask(); $continue = $io->ask('Continue ?','n'); // adds a default $continue = $io->askChoice('Continue ? (name)',['y','n']);","title":"Inputs"},{"location":"console/#alerts","text":"Display alerts to users, warning and error will be displayed stderr . $io->info('INFO', 'This an info alert'); $io->success('SUCCESS', 'This is a success alert'); $io->warning('WARNING', 'This is a warning alert'); $io->error('ERROR', 'This an error alert');","title":"Alerts"},{"location":"console/#progress-bar","text":"Display a progress bar to user $io->progressBar(50, 100);","title":"Progress Bar"},{"location":"console/#status","text":"Often when running commands you are carrying out multiple tasks, and its nice to show these to the user. This is where the status method comes in handy, statuses are setup for ok , warning and error . $io->status('ok', 'Delete file'); $io->status('warning', 'Directory is writable'); $io->status('error', 'Create directory'); You can also add your own status $io->setStatus('skipped','blue'); $io->setStatus('ignored','yellow');","title":"Status"},{"location":"console/#testing","text":"Create your PHP test file and add the ConsoleIntegrationTestTrait , then create the Command object using the TestConsoleIo and call the setupIntegrationTesting function. <?php declare(strict_types=1); namespace App\\Command; use PHPUnit\\Framework\\TestCase; use Lightning\\Console\\TestSuite\\ConsoleIntegrationTestTrait; final class HelloWordCommandTest extends TestCase { use ConsoleIntegrationTestTrait; public function setUp(): void { $command = new HelloWorldCommand(new ConsoleArgumentParser(), new TestConsoleIo()); $this->setupIntegrationTesting($command); } public function testExitSuccesss(): void { $this->execute(); $this->assertExitSuccess(); $this->assertOutputContains('Hello world!'); } } To execute the Command with arguments $this->execute(['--bold','jon']); If your command asks for input from the user, you can pass the input in the execute method $this->execute([],['jon']);","title":"Testing"},{"location":"console/#assertion-methods","text":"$this->assertExitSuccess(); $this->assertExitError(); $this->assertExitCode(3); // stdout $this->assertOutputContains('x'); $this->assertOutputNotContains('x'); $this->assertOutputEmpty(); $this->assertOutputNotEmpty(); $this->assertOutputMatchesRegularExpression('/foo/'); $this->assertOutputDoesNotMatchRegularExpression('/foo/'); // stderr $this->assertErrorContains('x'); $this->assertErrorNotContains('x'); $this->assertErrorEmpty(); $this->assertErrorNotEmpty(); $this->assertErrorMatchesRegularExpression('/foo/'); $this->assertErrorDoesNotMatchRegularExpression('/foo/');","title":"Assertion methods"},{"location":"container/","text":"PSR-11: Dependency Injection Container Superfast lightweight DI container with autowiring and autoconfiguration support. Usage Create a a definitions file, and configure the Services using inline factory methods return [ LoggerInterface::class => function() { return new Logger(__DIR__ . '/logs/application.log'); }, Spider::class => function(ContainerInterface $container) { $logger = $container->get(LoggerInterface::class); return new Spider($logger, true); } ]; Create the Container $services = include __DIR__ . '/config/services.php'; $container = new Container($services); To retrieve a service from the Container $spider = $container->get(Spider::class); Registering Services Typically you would load services from the definitions, which under the hood registers them these functions. // You can add a service to be managed by the container like this $container->register(Logger::class); // To configure how a service will be created or call setter methods , you can use an inline factory method $container->register(Database::class, function(ContainerInterface $container){ $logger = $container->get(LoggerInterface::class); return new Database($logger, env('DB_USERNAME'), env('DB_PASSWORD')); })) // If you already have the singleton instance, then you can add it like this $container->register(CacheInterface::class, new Cache()); By default an object is only resolved once when you call get and then the same object will be returned going foward, if you need to create a new object from the class or factory method. $container->resolve(CacheInterface::class) Autowiring To enable autowiring $container->enableAutowiring(); Autoconfigure You can configure the Container to automatically manage services, so if the class exists it will try to resolve it. $container->enableAutoConfigure();","title":"Container"},{"location":"container/#psr-11-dependency-injection-container","text":"Superfast lightweight DI container with autowiring and autoconfiguration support.","title":"PSR-11: Dependency Injection Container"},{"location":"container/#usage","text":"Create a a definitions file, and configure the Services using inline factory methods return [ LoggerInterface::class => function() { return new Logger(__DIR__ . '/logs/application.log'); }, Spider::class => function(ContainerInterface $container) { $logger = $container->get(LoggerInterface::class); return new Spider($logger, true); } ]; Create the Container $services = include __DIR__ . '/config/services.php'; $container = new Container($services); To retrieve a service from the Container $spider = $container->get(Spider::class);","title":"Usage"},{"location":"container/#registering-services","text":"Typically you would load services from the definitions, which under the hood registers them these functions. // You can add a service to be managed by the container like this $container->register(Logger::class); // To configure how a service will be created or call setter methods , you can use an inline factory method $container->register(Database::class, function(ContainerInterface $container){ $logger = $container->get(LoggerInterface::class); return new Database($logger, env('DB_USERNAME'), env('DB_PASSWORD')); })) // If you already have the singleton instance, then you can add it like this $container->register(CacheInterface::class, new Cache()); By default an object is only resolved once when you call get and then the same object will be returned going foward, if you need to create a new object from the class or factory method. $container->resolve(CacheInterface::class)","title":"Registering Services"},{"location":"container/#autowiring","text":"To enable autowiring $container->enableAutowiring();","title":"Autowiring"},{"location":"container/#autoconfigure","text":"You can configure the Container to automatically manage services, so if the class exists it will try to resolve it. $container->enableAutoConfigure();","title":"Autoconfigure"},{"location":"controller/","text":"Controller A PSR-7 Controller with TemplateRenderer , and a couple of important methods render , renderJson , renderFile and redirect to keep code dry when working with ResponseInterface . Create your application controller with the factory method createResponse se Lightning\\Controller\\AbstractController as BaseController; class AppController extends BaseController { public function createResponse(): ResponseInterface { return new Response(); // A factory method } } Now create your controllers class ArticlesController extends AppController { public function index(ServerRequest $request): ResponseInterface { return $this->render('articles/index', [ 'title' => 'foo', ]); } } Rendering To a render a View return $this->render('articles/index', [ 'title' => 'foo', ]); To render JSON return $this->renderJson([ 'title' => 'foo', ]); Redirecting To handle redirects $this->redirect('/articles/view/123'); // or e.g. https://www.example.com File Response To render a file in a Response return $this->renderFile('/var/www/downloads/2021.pdf'); return $this->renderFile('/var/www/downloads/2021.txt',['download' => 'false']); // To not force download return $this->renderFile('/var/www/downloads/2021.pdf',['name' =>'important.pdf']); // To give the file a different name Callbacks The design of this deliberately does not include a specific event implementation e.g. PSR-14 event or Hooks. These methods are provided as the first point of call for getting the desired behavior. The following callbacks methods are called allowing you modify the behavior of the Controller , you can create different versions of the Controller using these methods to carry out different actions such as triggering PSR-14 events etc or using hooks or quite simply just placing the logic in the methods. initialize beforeRender afterRender beforeRedirect afterRedirect Here is how you could implement PSR-14 Events using the controller callbacks. abstract class AbstractEventsController extends AbstractController { protected EventDispatcherInterface $eventDispatcher; public function __construct(TemplateRenderer $templateRenderer, EventDispatcherInterface $eventDispatcher) { $this->eventDispatcher = $eventDispatcher; parent::__construct($templateRenderer); $this->eventDispatcher->dispatch(new InitializeEvent($this)); } protected function beforeRender(): ?ResponseInterface { return $this->eventDispatcher->dispatch(new BeforeRenderEvent($this, $this->request))->getResponse(); // Response object or null } protected function afterRender(ResponseInterface $response): ResponseInterface { return $this->eventDispatcher->dispatch(new AfterRenderEvent($this, $this->request, $response))->getResponse(); } protected function beforeRedirect(string $url): ?ResponseInterface { return $this->eventDispatcher->dispatch(new BeforeRedirectEvent($this, $url, $this->request))->getResponse(); // Response object or null } protected function afterRedirect(ResponseInterface $response): ResponseInterface { return $this->eventDispatcher->dispatch(new AfterRedirectEvent($this, $this->request, $response))->getResponse(); } }","title":"Controller"},{"location":"controller/#controller","text":"A PSR-7 Controller with TemplateRenderer , and a couple of important methods render , renderJson , renderFile and redirect to keep code dry when working with ResponseInterface . Create your application controller with the factory method createResponse se Lightning\\Controller\\AbstractController as BaseController; class AppController extends BaseController { public function createResponse(): ResponseInterface { return new Response(); // A factory method } } Now create your controllers class ArticlesController extends AppController { public function index(ServerRequest $request): ResponseInterface { return $this->render('articles/index', [ 'title' => 'foo', ]); } }","title":"Controller"},{"location":"controller/#rendering","text":"To a render a View return $this->render('articles/index', [ 'title' => 'foo', ]); To render JSON return $this->renderJson([ 'title' => 'foo', ]);","title":"Rendering"},{"location":"controller/#redirecting","text":"To handle redirects $this->redirect('/articles/view/123'); // or e.g. https://www.example.com","title":"Redirecting"},{"location":"controller/#file-response","text":"To render a file in a Response return $this->renderFile('/var/www/downloads/2021.pdf'); return $this->renderFile('/var/www/downloads/2021.txt',['download' => 'false']); // To not force download return $this->renderFile('/var/www/downloads/2021.pdf',['name' =>'important.pdf']); // To give the file a different name","title":"File Response"},{"location":"controller/#callbacks","text":"The design of this deliberately does not include a specific event implementation e.g. PSR-14 event or Hooks. These methods are provided as the first point of call for getting the desired behavior. The following callbacks methods are called allowing you modify the behavior of the Controller , you can create different versions of the Controller using these methods to carry out different actions such as triggering PSR-14 events etc or using hooks or quite simply just placing the logic in the methods. initialize beforeRender afterRender beforeRedirect afterRedirect Here is how you could implement PSR-14 Events using the controller callbacks. abstract class AbstractEventsController extends AbstractController { protected EventDispatcherInterface $eventDispatcher; public function __construct(TemplateRenderer $templateRenderer, EventDispatcherInterface $eventDispatcher) { $this->eventDispatcher = $eventDispatcher; parent::__construct($templateRenderer); $this->eventDispatcher->dispatch(new InitializeEvent($this)); } protected function beforeRender(): ?ResponseInterface { return $this->eventDispatcher->dispatch(new BeforeRenderEvent($this, $this->request))->getResponse(); // Response object or null } protected function afterRender(ResponseInterface $response): ResponseInterface { return $this->eventDispatcher->dispatch(new AfterRenderEvent($this, $this->request, $response))->getResponse(); } protected function beforeRedirect(string $url): ?ResponseInterface { return $this->eventDispatcher->dispatch(new BeforeRedirectEvent($this, $url, $this->request))->getResponse(); // Response object or null } protected function afterRedirect(ResponseInterface $response): ResponseInterface { return $this->eventDispatcher->dispatch(new AfterRedirectEvent($this, $this->request, $response))->getResponse(); } }","title":"Callbacks"},{"location":"criteria/","text":"Criteria Criteria provides an SQL like condition searching on arrays of data. Usage Create the Criteria object passing the conditions. $criteria = new Criteria([ 'author_id' => 1234, 'status' => ['draft','active'], 'category !=' => ['not assigned'], 'title LIKE' => 'foo%', 'created_at BETWEEN' => ['2021-10-01 12:00:00','2021-10-15 00:00:00'] ]); foreach($records as $record) { $isMatch = $criteria->match($record); // do something }","title":"Criteria"},{"location":"criteria/#criteria","text":"Criteria provides an SQL like condition searching on arrays of data.","title":"Criteria"},{"location":"criteria/#usage","text":"Create the Criteria object passing the conditions. $criteria = new Criteria([ 'author_id' => 1234, 'status' => ['draft','active'], 'category !=' => ['not assigned'], 'title LIKE' => 'foo%', 'created_at BETWEEN' => ['2021-10-01 12:00:00','2021-10-15 00:00:00'] ]); foreach($records as $record) { $isMatch = $criteria->match($record); // do something }","title":"Usage"},{"location":"data-mapper/","text":"DataMapper DataMapper component implements the Data Mapper Pattern , this uses the Entity , Collection and QueryBuilder components. Example Create your DataMapper , ensuring that you add the table , fields properties and the mapDataToEntity method. /** * Article Mapper * * @method ?ArticleEntity find(QueryObject $query) * @method ?ArticleEntity findBy(array $criteria, array $options = []) * @method Collection|ArticleEntity[] findAll(QueryObject $query) * @method Collection|ArticleEntity[] findAllBy(array $criteria, array $options = []) */ class Article extends AbstractDataMapper { protected $primaryKey = 'id'; protected string $table = 'articles'; protected array $fields = [ 'id', 'title','body','author_id','created_at','updated_at' ]; public function mapDataToEntity(array $data): EntityInterface { return ArticleEntity::fromState($data); } } Finding records, this under the hood uses the QueryBuilder component. $entity = $article->findBy(['id' => 1000]); $entities = $article->findAllBy(['status' => 'new']); $count = $article->findCountBy(['status' => 'new']); $ids = $article->findListBy(['status <>' => 'draft']); $statuses = $article->findListBy(['status <>' => 'draft'],[ 'keyField'=> 'id', 'valueField' => 'status' ]); $grouped = $article->findListBy(['status <>' => 'draft'],[ 'keyField'=> 'id', 'valueField' => 'title' ,'groupField' => 'status' ]); You can carry out bulk operations, remember these don't trigger events or hooks . $count = $article->updateAllBy( ['status'=>'pending','owner'=> 1234], ['status'=>'approved'] ); $count = $aritcle->deleteAllBy([ 'status'=>'draft', 'created_date <' => date('Y-m-d H:i:s',strtotime('- 3 months')) ]); Query Object Under the hood, the find methods use the QueryObject , this object is passed to the Events and Hooks . $query = new QueryObject(['status' => 'pending'],['order' => 'title DESC']); $result = $mapper->find($query); $result = $mapper->findAll($query); $result = $mapper->findCount($query); $mapper->deleteAll($query); $mapper->updateAll($query, ['status'=> 'approved']); Collection The Utility\\Collection object is used to store the results from find operations and this is passed to the callback methods. Callbacks The design of this deliberately does not include a specific event implementation e.g. PSR-14 event or Hooks. These methods are provided as the first point of call for getting the desired behavior. The following callbacks methods are called allowing you modify the behavior of the DataMapper , you can create different versions of the DataMapper using these methods to carry out different actions such as triggering PSR-14 events etc or using hooks or quite simply just placing the logic in the methods. initialize - This is triggered when the data mapper is constructed beforeSave - triggered before beforeCreate or beforeUpdate beforeCreate - triggered on save if the operation is a create beforeUpdate - triggered on save if the operation is an update beforeDelete afterCreate - triggered on save if the operation was a create aterUpdate - triggered on save if the operation was an update afterSave - triggered after afterCreate or afterUpdate afterDelete beforeFind - triggered on find, findCount and findList afterFind - triggered on find and findList For example abstract AppDataMapper extends AbstractDataMapper { protected function beforeCreate(EntityInterface $entity): bool { return true; } protected function afterCreate(EntityInterface $entity): void { } protected function beforeUpdate(EntityInterface $entity): bool { return true; } protected function afterUpdate(EntityInterface $entity): void { } protected function beforeSave(EntityInterface $entity): bool { return true; } protected function afterSave(EntityInterface $entity): void { } protected function beforeDelete(EntityInterface $entity): bool { return true; } protected function afterDelete(EntityInterface $entity): void { } protected function beforeFind(QueryObject $query): bool { return true; } protected function afterFind(Collection $collection, QueryObject $query): void { } }","title":"DataMapper"},{"location":"data-mapper/#datamapper","text":"DataMapper component implements the Data Mapper Pattern , this uses the Entity , Collection and QueryBuilder components.","title":"DataMapper"},{"location":"data-mapper/#example","text":"Create your DataMapper , ensuring that you add the table , fields properties and the mapDataToEntity method. /** * Article Mapper * * @method ?ArticleEntity find(QueryObject $query) * @method ?ArticleEntity findBy(array $criteria, array $options = []) * @method Collection|ArticleEntity[] findAll(QueryObject $query) * @method Collection|ArticleEntity[] findAllBy(array $criteria, array $options = []) */ class Article extends AbstractDataMapper { protected $primaryKey = 'id'; protected string $table = 'articles'; protected array $fields = [ 'id', 'title','body','author_id','created_at','updated_at' ]; public function mapDataToEntity(array $data): EntityInterface { return ArticleEntity::fromState($data); } } Finding records, this under the hood uses the QueryBuilder component. $entity = $article->findBy(['id' => 1000]); $entities = $article->findAllBy(['status' => 'new']); $count = $article->findCountBy(['status' => 'new']); $ids = $article->findListBy(['status <>' => 'draft']); $statuses = $article->findListBy(['status <>' => 'draft'],[ 'keyField'=> 'id', 'valueField' => 'status' ]); $grouped = $article->findListBy(['status <>' => 'draft'],[ 'keyField'=> 'id', 'valueField' => 'title' ,'groupField' => 'status' ]); You can carry out bulk operations, remember these don't trigger events or hooks . $count = $article->updateAllBy( ['status'=>'pending','owner'=> 1234], ['status'=>'approved'] ); $count = $aritcle->deleteAllBy([ 'status'=>'draft', 'created_date <' => date('Y-m-d H:i:s',strtotime('- 3 months')) ]);","title":"Example"},{"location":"data-mapper/#query-object","text":"Under the hood, the find methods use the QueryObject , this object is passed to the Events and Hooks . $query = new QueryObject(['status' => 'pending'],['order' => 'title DESC']); $result = $mapper->find($query); $result = $mapper->findAll($query); $result = $mapper->findCount($query); $mapper->deleteAll($query); $mapper->updateAll($query, ['status'=> 'approved']);","title":"Query Object"},{"location":"data-mapper/#collection","text":"The Utility\\Collection object is used to store the results from find operations and this is passed to the callback methods.","title":"Collection"},{"location":"data-mapper/#callbacks","text":"The design of this deliberately does not include a specific event implementation e.g. PSR-14 event or Hooks. These methods are provided as the first point of call for getting the desired behavior. The following callbacks methods are called allowing you modify the behavior of the DataMapper , you can create different versions of the DataMapper using these methods to carry out different actions such as triggering PSR-14 events etc or using hooks or quite simply just placing the logic in the methods. initialize - This is triggered when the data mapper is constructed beforeSave - triggered before beforeCreate or beforeUpdate beforeCreate - triggered on save if the operation is a create beforeUpdate - triggered on save if the operation is an update beforeDelete afterCreate - triggered on save if the operation was a create aterUpdate - triggered on save if the operation was an update afterSave - triggered after afterCreate or afterUpdate afterDelete beforeFind - triggered on find, findCount and findList afterFind - triggered on find and findList For example abstract AppDataMapper extends AbstractDataMapper { protected function beforeCreate(EntityInterface $entity): bool { return true; } protected function afterCreate(EntityInterface $entity): void { } protected function beforeUpdate(EntityInterface $entity): bool { return true; } protected function afterUpdate(EntityInterface $entity): void { } protected function beforeSave(EntityInterface $entity): bool { return true; } protected function afterSave(EntityInterface $entity): void { } protected function beforeDelete(EntityInterface $entity): bool { return true; } protected function afterDelete(EntityInterface $entity): void { } protected function beforeFind(QueryObject $query): bool { return true; } protected function afterFind(Collection $collection, QueryObject $query): void { } }","title":"Callbacks"},{"location":"database/","text":"Database Database components come with PdoFactory , Connection and a QueryBuilder . PDO Factory Creates and configures PDO object to in a standard and secure way. use Lightning\\Database\\PdoFactory; $pdoFactory = new PdoFactory('mysql:host=127.0.0.1;port=3306;dbname=lightning', 'root', 'secret'); $pdo = $pdoFactory->create(); The default fetch mode for the PDO object to an associative array, however if you want to change it to objects. $pdo->setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE,PDO::FETCH_OBJ); You maybe also want the PdoFactory to work differently class CustomPdoFactory implements PdoFactoryInterface { public function create(): PDO { return new PDO(env('DB_URL'), env('DB_USERNAME'), env('DB_PASSWORD')); } } Connection Works with PDO and PSR-3 Logger, also allows you to connect and disconnect as needed. Usage $pdoFactory = new PdoFactory('mysql:host=mysql;port=3306;dbname=lightning', 'root', 'root'); // $db = new Connection($pdoFactory); $db->connect(); $db->disconnect(); $statement = $db->execute('SELECT * FROM articles') foreach($statement as $row){ dd($row); } Placholders values don't have to be quoted To fetch a single record, using positional ? placeholders $row = $db->execute('SELECT * FROM articles WHERE id = ? LIMIT 1', [1000]) ->fetch(); To fetch multiple records, using named :name placeholders $rows = $db->execute('SELECT * FROM articles WHERE id = :id ', ['id' => 1000]) ->fetchAll(); You can also pass any query object that implements Stringable , such as the QueryBuilder object. $query = (new QueryBuilder())->select('*') ->from('users') ->where('id = :id','active = :active'); $users = $db->execute($query, ['id' => 1000,'status' => 'active'])->fetchAll(); Insert/Update/Delete To insert a row into the database $db->insert('articles', [ 'title' => 'This is an article' ]); To update a row or rows in the database, with the id values $db->update('articles', [ 'title' => 'This is an article' ], ['id' => 1234]); To delete a row or rows in the database, with the id values $db->delete('articles',['id' => 1234]); Row The Row object can be used with PDO , this is an object with array access, and some other handy features when working with a result from the database. $row = $connection->execute('SELECT * FROM articles')->fetchObject(Row::class); $title = $row->title; $title = $row['title']; Resources https://phpdelusions.net/pdo","title":"Database"},{"location":"database/#database","text":"Database components come with PdoFactory , Connection and a QueryBuilder .","title":"Database"},{"location":"database/#pdo-factory","text":"Creates and configures PDO object to in a standard and secure way. use Lightning\\Database\\PdoFactory; $pdoFactory = new PdoFactory('mysql:host=127.0.0.1;port=3306;dbname=lightning', 'root', 'secret'); $pdo = $pdoFactory->create(); The default fetch mode for the PDO object to an associative array, however if you want to change it to objects. $pdo->setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE,PDO::FETCH_OBJ); You maybe also want the PdoFactory to work differently class CustomPdoFactory implements PdoFactoryInterface { public function create(): PDO { return new PDO(env('DB_URL'), env('DB_USERNAME'), env('DB_PASSWORD')); } }","title":"PDO Factory"},{"location":"database/#connection","text":"Works with PDO and PSR-3 Logger, also allows you to connect and disconnect as needed.","title":"Connection"},{"location":"database/#usage","text":"$pdoFactory = new PdoFactory('mysql:host=mysql;port=3306;dbname=lightning', 'root', 'root'); // $db = new Connection($pdoFactory); $db->connect(); $db->disconnect(); $statement = $db->execute('SELECT * FROM articles') foreach($statement as $row){ dd($row); } Placholders values don't have to be quoted To fetch a single record, using positional ? placeholders $row = $db->execute('SELECT * FROM articles WHERE id = ? LIMIT 1', [1000]) ->fetch(); To fetch multiple records, using named :name placeholders $rows = $db->execute('SELECT * FROM articles WHERE id = :id ', ['id' => 1000]) ->fetchAll(); You can also pass any query object that implements Stringable , such as the QueryBuilder object. $query = (new QueryBuilder())->select('*') ->from('users') ->where('id = :id','active = :active'); $users = $db->execute($query, ['id' => 1000,'status' => 'active'])->fetchAll();","title":"Usage"},{"location":"database/#insertupdatedelete","text":"To insert a row into the database $db->insert('articles', [ 'title' => 'This is an article' ]); To update a row or rows in the database, with the id values $db->update('articles', [ 'title' => 'This is an article' ], ['id' => 1234]); To delete a row or rows in the database, with the id values $db->delete('articles',['id' => 1234]);","title":"Insert/Update/Delete"},{"location":"database/#row","text":"The Row object can be used with PDO , this is an object with array access, and some other handy features when working with a result from the database. $row = $connection->execute('SELECT * FROM articles')->fetchObject(Row::class); $title = $row->title; $title = $row['title'];","title":"Row"},{"location":"database/#resources","text":"https://phpdelusions.net/pdo","title":"Resources"},{"location":"dotenv/","text":"Dotenv A ultra simple and lightweight Dotenv parser. empty lines will be skipped lines that start with # are ignored lines should be NAME=value or NAME=\"some value with space\", but no spaces before the var name, and no spaces before or after the equal sign. No cleansing is done. Usage In your bootstrap file create the object with the directory that you want to use and load this // Load .env in the working directory (new Dotenv(dirname(__DIR__)))->load(); An example .env file will look like this, key values should be written correctly KEY=value with no spaces. No comments should be added after values. # This is a comment line KEY=value Env function This package also comes with an env function. $value = env('key');","title":"Dotenv"},{"location":"dotenv/#dotenv","text":"A ultra simple and lightweight Dotenv parser. empty lines will be skipped lines that start with # are ignored lines should be NAME=value or NAME=\"some value with space\", but no spaces before the var name, and no spaces before or after the equal sign. No cleansing is done.","title":"Dotenv"},{"location":"dotenv/#usage","text":"In your bootstrap file create the object with the directory that you want to use and load this // Load .env in the working directory (new Dotenv(dirname(__DIR__)))->load(); An example .env file will look like this, key values should be written correctly KEY=value with no spaces. No comments should be added after values. # This is a comment line KEY=value","title":"Usage"},{"location":"dotenv/#env-function","text":"This package also comes with an env function. $value = env('key');","title":"Env function"},{"location":"entity/","text":"Entity An is a lightweight persistance domain object, which usually each entity represents a row in your table in the database. Usage Create your Entity class using a singular name, add the properties that represent your data in the table as private and then create the setters and getters. When working with entities, unless the datasource allows a null value do not set a default null value just for the sake of it, that is incorrect. class User extends AbstractEntity { private int $id; private string $email; private string $password; private string $created_at; private string $updated_at; // hook called when the entity is created protected function initialize(): void { } public function getId(): ?int { return $this->id ?? null; } public function getEmail(): ?string { return $this->email ?? null; } public function setEmail(string $email): static { $this->email = $email; return $this; } public function getPassword(): ?string { return $this->password ?? null; } public function setPassword(string $password): static { $this->password = $password; return $this; } public function getCreatedAt(): ?string { return $this->created_at ?? null; } public function setCreatedAt(string $created_at): static { $this->created_at = $created_at; return $this; } public function getUpdatedAt(): ?string { return $this->updated_at ?? null; } public function setUpdatedAt(string $updated_at): static { $this->updated_at = $updated_at; return $this; } }","title":"Entity"},{"location":"entity/#entity","text":"An is a lightweight persistance domain object, which usually each entity represents a row in your table in the database.","title":"Entity"},{"location":"entity/#usage","text":"Create your Entity class using a singular name, add the properties that represent your data in the table as private and then create the setters and getters. When working with entities, unless the datasource allows a null value do not set a default null value just for the sake of it, that is incorrect. class User extends AbstractEntity { private int $id; private string $email; private string $password; private string $created_at; private string $updated_at; // hook called when the entity is created protected function initialize(): void { } public function getId(): ?int { return $this->id ?? null; } public function getEmail(): ?string { return $this->email ?? null; } public function setEmail(string $email): static { $this->email = $email; return $this; } public function getPassword(): ?string { return $this->password ?? null; } public function setPassword(string $password): static { $this->password = $password; return $this; } public function getCreatedAt(): ?string { return $this->created_at ?? null; } public function setCreatedAt(string $created_at): static { $this->created_at = $created_at; return $this; } public function getUpdatedAt(): ?string { return $this->updated_at ?? null; } public function setUpdatedAt(string $updated_at): static { $this->updated_at = $updated_at; return $this; } }","title":"Usage"},{"location":"event/","text":"Event A lightweight PSR-14: Event Dispatcher implementation with extended ListenerProviderInterface called the ListenerRegistry . Usage Create the EventDispatcher object with the ListenerRegistry . $listenerRegistry = new ListenerRegistry(); $eventDispatcher = new EventDispatcher($listenerRegistry); Dispatch an event $event = new CreditCardPaymentAccepted(); $eventDispatcher->dispatch($event); Listener Registry To add any callable use the registerListener method. $registry = new ListenerRegistry(); $registry->registerListener(AfterOrder::class, [$this, 'afterOrder']); $registry->registerListener(AfterOrder::class, function(AfterOrder $order){ // do something }); You can remove a listener like so $registry->unregisterListener(AfterOrder::class, [$this, 'afterOrder']); Events There is a AbstractEvent and a AbstractStoppableEvent class which you can use as a base for your event objects. class CustomEvent extends AbstractStoppableEvent { public function __construct(object $source, protected array $payload) { parent::__construct($source); } public function getPayload() : array { return $this->payload; } } $event = new CustomEvent($this); $source = $event->getSource(); // The object where the Event was triggered, e.g. Controller, Model etc $timestamp = $event->getTimestamp(); $bool = $event->isPropagationStopped(); // AbstractStoppableEvent only $event->stopPropagation(); // AbstractStoppableEvent only Listeners A special Listner class is available that would be compatible with other EventDispatchers and at the same time allow class MyListener extends AbstractListener { public function handle(BeforeSend $event) : void { // do something } } Event Exception An EventException class is marker exception to throw within your Events, they have no special purpose other than identification.","title":"Event"},{"location":"event/#event","text":"A lightweight PSR-14: Event Dispatcher implementation with extended ListenerProviderInterface called the ListenerRegistry .","title":"Event"},{"location":"event/#usage","text":"Create the EventDispatcher object with the ListenerRegistry . $listenerRegistry = new ListenerRegistry(); $eventDispatcher = new EventDispatcher($listenerRegistry); Dispatch an event $event = new CreditCardPaymentAccepted(); $eventDispatcher->dispatch($event);","title":"Usage"},{"location":"event/#listener-registry","text":"To add any callable use the registerListener method. $registry = new ListenerRegistry(); $registry->registerListener(AfterOrder::class, [$this, 'afterOrder']); $registry->registerListener(AfterOrder::class, function(AfterOrder $order){ // do something }); You can remove a listener like so $registry->unregisterListener(AfterOrder::class, [$this, 'afterOrder']);","title":"Listener Registry"},{"location":"event/#events","text":"There is a AbstractEvent and a AbstractStoppableEvent class which you can use as a base for your event objects. class CustomEvent extends AbstractStoppableEvent { public function __construct(object $source, protected array $payload) { parent::__construct($source); } public function getPayload() : array { return $this->payload; } } $event = new CustomEvent($this); $source = $event->getSource(); // The object where the Event was triggered, e.g. Controller, Model etc $timestamp = $event->getTimestamp(); $bool = $event->isPropagationStopped(); // AbstractStoppableEvent only $event->stopPropagation(); // AbstractStoppableEvent only","title":"Events"},{"location":"event/#listeners","text":"A special Listner class is available that would be compatible with other EventDispatchers and at the same time allow class MyListener extends AbstractListener { public function handle(BeforeSend $event) : void { // do something } }","title":"Listeners"},{"location":"event/#event-exception","text":"An EventException class is marker exception to throw within your Events, they have no special purpose other than identification.","title":"Event Exception"},{"location":"fixture/","text":"Fixture Easily add Fixtures to PHPUnit tests. Usage Load your schema into the test database, then each time you run a test, the tables will be truncated and reinserted for the loaded fixtures. First create a Fixture, e.g. tests/Fixture/ContactsFixture , you will need to set a table property. <?php declare(strict_types=1); namespace Lightning\\Test\\Fixture; use Lightning\\Fixture\\AbstractFixture as Fixture; final class MigrationsFixture extends Fixture { protected string $table = 'migrations'; protected array $records = [ [ 'id' => 1000, 'version' => 20210928140841, 'created_at' => '2021-09-28 16:10:00' ] ]; } Then in your phpunit test case final class ContactsControllerTest extends TestCase { protected function setUp() : void { $pdo = new PDO(getenv('DB_URL'), getenv('DB_USERNAME'), getenv('DB_PASSWORD')); $this->fixtureManager = new FixtureManager($pdo); $this->fixtureManager->load([ContactsFixture::class]); // this loads the fixtures } protected function tearDown() : void { $this->fixtureManager->unload(); // This will truncate the fixture tables } }","title":"Fixure"},{"location":"fixture/#fixture","text":"Easily add Fixtures to PHPUnit tests.","title":"Fixture"},{"location":"fixture/#usage","text":"Load your schema into the test database, then each time you run a test, the tables will be truncated and reinserted for the loaded fixtures. First create a Fixture, e.g. tests/Fixture/ContactsFixture , you will need to set a table property. <?php declare(strict_types=1); namespace Lightning\\Test\\Fixture; use Lightning\\Fixture\\AbstractFixture as Fixture; final class MigrationsFixture extends Fixture { protected string $table = 'migrations'; protected array $records = [ [ 'id' => 1000, 'version' => 20210928140841, 'created_at' => '2021-09-28 16:10:00' ] ]; } Then in your phpunit test case final class ContactsControllerTest extends TestCase { protected function setUp() : void { $pdo = new PDO(getenv('DB_URL'), getenv('DB_USERNAME'), getenv('DB_PASSWORD')); $this->fixtureManager = new FixtureManager($pdo); $this->fixtureManager->load([ContactsFixture::class]); // this loads the fixtures } protected function tearDown() : void { $this->fixtureManager->unload(); // This will truncate the fixture tables } }","title":"Usage"},{"location":"formatter/","text":"Formatter MessageFormatter The MessageFormatter is a simple formater $formatter = new MessageFormatter(); echo $formatter->format('Hello {name}',['name' => 'jon']); You can also display messages depending up on the count argument supplied, you must always provide at least 3 variations, zero , one and many , if the count does not exist in the index, it will return the last message in the invoice. echo $formater->format('You have no invoices|You have one invoice|You have {count} invoices',['count' => 4]); // you have 4 invoices echo $formater->format('You have no invoices|You have one invoice|You have two invoices| You have {count} invoices',['count' => 3]); // you have 3 invoices DateTimeFormatter The DateTimeFormatter object gives you an application friendly way to work with dates and time. You can also configure this object in your DI container and then change the settings for the object in the Middleware or Controller which will then change how your whole application formats dates for each user, depending upon their preferences. date_default_timezone_set('UTC'); Create a DateTimeFormatter object in your DI container making sure the same object is injected into dependencies, so that any changes made to the configurion are used elsewhere in the application. $formatter = new DateTimeFormatter(); // UTC with `Y-m-d` for dates and `H:i:s` for times or `Y-m-d H:i:s` for datetime In your Controller you can configure the DateTimeFormatter object based upon the user preferences. $formatter->setTimezone('Europe/London'); $formatter->setDateTimeFormat('d/m/Y H:i:s'); $formatter->setTimeFormat('H:i:s'); $formatter->setDateFormat('d/m/Y'); To format a datetime using configured settings, including timezone: $now = new DateTime(); // or string, or unix timestamp or class that implements Stringable // Use the configured default formats $formatter->date($now); $formatter->time($now); $formatter->datetime($now); // use a custom format $formatter->format($now); // formats as datetime if no format provided $formatter->format($now,'D, d M Y H:i:s O'); // use any DateTime format but still converting to user timezone NumberFormatter The NumberFormatter object gives you an application friendly way to work with numbers. You can also configure this object in your DI container and then change the settings for the object in the Middleware or Controller which will then change how your whole application formats numbers for each user, depending upon their preferences. $formatter = new NumberFormatter(); // Default currency USD and thousands symbol configured to , and decimals symbol to . You can pass a float or integer , or a string representation of one of those. Passing a null value or an empty string will throw an exception. The format number will format all numbers without any decimal places unless you provide a second argument of places. The places argument is ignored on values which are integer or strings only have integers in them and do not include the . decimal seperator. $formatter->format(123456.7890); // 123,456 $formatter->format(123456.7890,2); // 123,456.78 $formatter->format(123456,2); // 123,456 $formatter->format((float) 1234, 2); // 1,234.00 To use precision $formatter->precision(123456.7890); // 123,456.789 - use default of 3 $formatter->precision(123456.7890,2); // 123,456.78 Currencies The following currencies have already been setup but can be overrided USD , GBP , EUR , JPY , CAD and CHF Like the format method, if you provide an integer value it wont add .00 $formatter->currency(123456.7890); // $123,456.78 - uses default currency USD and currency setting of 2 $formatter->currency(123456.7890, 'GBP'); // \u00a3123,456.78 // work with 00 $formatter->currency(123456, 'GBP'); // \u00a3123,456 $formatter->currency((float) 123456, 'GBP'); // \u00a3123,456.00 // working with negatives $formatter->currency(-123456.7890); // (\u00a3123,456.78) // passing a unkown currency $formatter->currency(123456.7890, 'FOO'); // 123,456.78 FOO - this is unkown currency To add a custom currency $formatter->addCurrency('BTC', '\u0e3f', '', 3); $formatter->currency(0.1234567, 'BTC'); // \u0e3f0.123 $formatter->currency(1234.5678, 'BTC'); // \u0e3f1,234.568 Percentages By default percentages are formatted with a precision of 2 unless the number is an integer, to force the .00 then make sure to always pass a float. $formatter->toPercentage(99); // 99% $formatter->toPercentage(99.9999,0); // / 99% $formatter->toPercentage(99.9999); // 99.99 $formatter->toPercentage((float) 99); // 99.00% $formatter->toPercentage(99.9999,3); // 99.999 to use custom precision Readable Sizes Convert bytes into human readable sizes, for sizes greater than KB precision will be used for non round numbers. $number->toReadableSize(0); // 0 B $number->toReadableSize(1073741824); // 1,024 MB To force precision $number->toReadableSize(0); // 0 B Todo In future I plan to add these [ ] DateTimeFormatterInterface (just include setTimezone not others) [ ] NumberFormatterInterface maybe [ ] Add IcuDateTimeFormatter [ ] Add IcuNumberFormatter","title":"Formatter"},{"location":"formatter/#formatter","text":"","title":"Formatter"},{"location":"formatter/#messageformatter","text":"The MessageFormatter is a simple formater $formatter = new MessageFormatter(); echo $formatter->format('Hello {name}',['name' => 'jon']); You can also display messages depending up on the count argument supplied, you must always provide at least 3 variations, zero , one and many , if the count does not exist in the index, it will return the last message in the invoice. echo $formater->format('You have no invoices|You have one invoice|You have {count} invoices',['count' => 4]); // you have 4 invoices echo $formater->format('You have no invoices|You have one invoice|You have two invoices| You have {count} invoices',['count' => 3]); // you have 3 invoices","title":"MessageFormatter"},{"location":"formatter/#datetimeformatter","text":"The DateTimeFormatter object gives you an application friendly way to work with dates and time. You can also configure this object in your DI container and then change the settings for the object in the Middleware or Controller which will then change how your whole application formats dates for each user, depending upon their preferences. date_default_timezone_set('UTC'); Create a DateTimeFormatter object in your DI container making sure the same object is injected into dependencies, so that any changes made to the configurion are used elsewhere in the application. $formatter = new DateTimeFormatter(); // UTC with `Y-m-d` for dates and `H:i:s` for times or `Y-m-d H:i:s` for datetime In your Controller you can configure the DateTimeFormatter object based upon the user preferences. $formatter->setTimezone('Europe/London'); $formatter->setDateTimeFormat('d/m/Y H:i:s'); $formatter->setTimeFormat('H:i:s'); $formatter->setDateFormat('d/m/Y'); To format a datetime using configured settings, including timezone: $now = new DateTime(); // or string, or unix timestamp or class that implements Stringable // Use the configured default formats $formatter->date($now); $formatter->time($now); $formatter->datetime($now); // use a custom format $formatter->format($now); // formats as datetime if no format provided $formatter->format($now,'D, d M Y H:i:s O'); // use any DateTime format but still converting to user timezone","title":"DateTimeFormatter"},{"location":"formatter/#numberformatter","text":"The NumberFormatter object gives you an application friendly way to work with numbers. You can also configure this object in your DI container and then change the settings for the object in the Middleware or Controller which will then change how your whole application formats numbers for each user, depending upon their preferences. $formatter = new NumberFormatter(); // Default currency USD and thousands symbol configured to , and decimals symbol to . You can pass a float or integer , or a string representation of one of those. Passing a null value or an empty string will throw an exception. The format number will format all numbers without any decimal places unless you provide a second argument of places. The places argument is ignored on values which are integer or strings only have integers in them and do not include the . decimal seperator. $formatter->format(123456.7890); // 123,456 $formatter->format(123456.7890,2); // 123,456.78 $formatter->format(123456,2); // 123,456 $formatter->format((float) 1234, 2); // 1,234.00 To use precision $formatter->precision(123456.7890); // 123,456.789 - use default of 3 $formatter->precision(123456.7890,2); // 123,456.78","title":"NumberFormatter"},{"location":"formatter/#currencies","text":"The following currencies have already been setup but can be overrided USD , GBP , EUR , JPY , CAD and CHF Like the format method, if you provide an integer value it wont add .00 $formatter->currency(123456.7890); // $123,456.78 - uses default currency USD and currency setting of 2 $formatter->currency(123456.7890, 'GBP'); // \u00a3123,456.78 // work with 00 $formatter->currency(123456, 'GBP'); // \u00a3123,456 $formatter->currency((float) 123456, 'GBP'); // \u00a3123,456.00 // working with negatives $formatter->currency(-123456.7890); // (\u00a3123,456.78) // passing a unkown currency $formatter->currency(123456.7890, 'FOO'); // 123,456.78 FOO - this is unkown currency To add a custom currency $formatter->addCurrency('BTC', '\u0e3f', '', 3); $formatter->currency(0.1234567, 'BTC'); // \u0e3f0.123 $formatter->currency(1234.5678, 'BTC'); // \u0e3f1,234.568","title":"Currencies"},{"location":"formatter/#percentages","text":"By default percentages are formatted with a precision of 2 unless the number is an integer, to force the .00 then make sure to always pass a float. $formatter->toPercentage(99); // 99% $formatter->toPercentage(99.9999,0); // / 99% $formatter->toPercentage(99.9999); // 99.99 $formatter->toPercentage((float) 99); // 99.00% $formatter->toPercentage(99.9999,3); // 99.999 to use custom precision","title":"Percentages"},{"location":"formatter/#readable-sizes","text":"Convert bytes into human readable sizes, for sizes greater than KB precision will be used for non round numbers. $number->toReadableSize(0); // 0 B $number->toReadableSize(1073741824); // 1,024 MB To force precision $number->toReadableSize(0); // 0 B","title":"Readable Sizes"},{"location":"formatter/#todo","text":"In future I plan to add these [ ] DateTimeFormatterInterface (just include setTimezone not others) [ ] NumberFormatterInterface maybe [ ] Add IcuDateTimeFormatter [ ] Add IcuNumberFormatter","title":"Todo"},{"location":"hook/","text":"Hooks Hooks package allows you to modify or extend the behavior of an object using the Interceptor pattern . Usage Register a hook to a method or multiple methods, by default all hooks can cancel the behavior that is being hooked into. The triggerHook method always returns true even if there are no hooks registered, it only returns false if the hook was stoppable and the method returned false . class MyObject { use HookTrait; public function __construct() { $this->registerHook('beforeFind','doSomething'); } protected function doSomething(array $criteria) { return !empty($criteria); } public function find(array $criteria) : bool { if(!$this->triggerHook('beforeFind',[$criteria])){ return false; } $result = $this->dataSource->find($criteria); //.. do something $this->triggerHook('afterFind',[$result, $criteria], false); } } Differences between Hook and Event , hooks are only triggered on the object itself, as opposed to any callable and there is a standard way to register a hook, making it more extendable.","title":"Hooks"},{"location":"hook/#hooks","text":"Hooks package allows you to modify or extend the behavior of an object using the Interceptor pattern .","title":"Hooks"},{"location":"hook/#usage","text":"Register a hook to a method or multiple methods, by default all hooks can cancel the behavior that is being hooked into. The triggerHook method always returns true even if there are no hooks registered, it only returns false if the hook was stoppable and the method returned false . class MyObject { use HookTrait; public function __construct() { $this->registerHook('beforeFind','doSomething'); } protected function doSomething(array $criteria) { return !empty($criteria); } public function find(array $criteria) : bool { if(!$this->triggerHook('beforeFind',[$criteria])){ return false; } $result = $this->dataSource->find($criteria); //.. do something $this->triggerHook('afterFind',[$result, $criteria], false); } } Differences between Hook and Event , hooks are only triggered on the object itself, as opposed to any callable and there is a standard way to register a hook, making it more extendable.","title":"Usage"},{"location":"logger/","text":"PSR-3 Logger A lightweight PSR-3 Logger component. Usage $logger = new Logger('application'); $logger->addHandler(new FileHandler('/var/www/logs/application.log')); // then use the PSR-3 Logging methods $logger->log(LogLevel::ERROR, 'An error has occured'); Handling When creating handler you can set the minimum log level to be used, if the handler is called but the log level is less, then it will not log anything. $handler = new FileHandler('/var/www/logs/application.log', LogLevel::WARNING); Custom Handlers Create your own custom handler with ease. class CustomHandler extends AbstractHandler { public function handle(LogMessage $message, string $level, string $channel, DateTimeImmutable $dateTime): bool { return true; } }","title":"Logger"},{"location":"logger/#psr-3-logger","text":"A lightweight PSR-3 Logger component.","title":"PSR-3 Logger"},{"location":"logger/#usage","text":"$logger = new Logger('application'); $logger->addHandler(new FileHandler('/var/www/logs/application.log')); // then use the PSR-3 Logging methods $logger->log(LogLevel::ERROR, 'An error has occured');","title":"Usage"},{"location":"logger/#handling","text":"When creating handler you can set the minimum log level to be used, if the handler is called but the log level is less, then it will not log anything. $handler = new FileHandler('/var/www/logs/application.log', LogLevel::WARNING);","title":"Handling"},{"location":"logger/#custom-handlers","text":"Create your own custom handler with ease. class CustomHandler extends AbstractHandler { public function handle(LogMessage $message, string $level, string $channel, DateTimeImmutable $dateTime): bool { return true; } }","title":"Custom Handlers"},{"location":"message-queue/","text":"Message Queue (MQ) This component provides a messaging queue, using Redis , database (Postgres, MySQL, or Sqlite) or an in memory version (for testing). Usage First create the message queue object $queue = new MemoryMessageQueue(); Create your message object that you want to send class Message { public function __construct(protected string $body) { } public function getBody() : string { return $this->body } } To send the message to the queue called default $queue->send('default',new Message('jon@bloggs.co.uk')); // This will probably be in service or controller Then to receive messages from the default queue $message = $queue->receive('default'); // This will be in a cron job somewhere Message Queues Redis Create the RedisMessageQueue object $redis = new Redis(); $redis->pconnect('redis', 6379); $queue = new RedisMessageQueue($redis); Database Message Queue (PDO) Create the database table MySQL CREATE TABLE queue ( id MEDIUMINT NOT NULL AUTO_INCREMENT, body TEXT, queue VARCHAR(100) NOT NULL, scheduled DATETIME NOT NULL, created_at DATETIME DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (id) ); Sqlite CREATE TABLE queue ( id INTEGER PRIMARY KEY AUTOINCREMENT, body TEXT NOT NULL, queue TEXT NOT NULL, scheduled DATETIME NOT NULL, created_at DATETIME DEFAULT CURRENT_TIMESTAMP ); Postgres With Postgres , serialized PHP objects might have null byte characters such as when using private properties, this becomes a problem for Postgres as the data would have to be BYTEA and not a string. Therefore when using Postgres as the backend, the serialized string will be encoded/decoded with base64 , so either avoid private properties or create custome serialization which encodes/decodes the object. CREATE TABLE queue ( id SERIAL PRIMARY KEY, body TEXT, queue VARCHAR(100) NOT NULL, scheduled TIMESTAMP(0) NOT NULL, created_at TIMESTAMP(0) DEFAULT CURRENT_TIMESTAMP );","title":"Message Queue"},{"location":"message-queue/#message-queue-mq","text":"This component provides a messaging queue, using Redis , database (Postgres, MySQL, or Sqlite) or an in memory version (for testing).","title":"Message Queue (MQ)"},{"location":"message-queue/#usage","text":"First create the message queue object $queue = new MemoryMessageQueue(); Create your message object that you want to send class Message { public function __construct(protected string $body) { } public function getBody() : string { return $this->body } } To send the message to the queue called default $queue->send('default',new Message('jon@bloggs.co.uk')); // This will probably be in service or controller Then to receive messages from the default queue $message = $queue->receive('default'); // This will be in a cron job somewhere","title":"Usage"},{"location":"message-queue/#message-queues","text":"","title":"Message Queues"},{"location":"message-queue/#redis","text":"Create the RedisMessageQueue object $redis = new Redis(); $redis->pconnect('redis', 6379); $queue = new RedisMessageQueue($redis);","title":"Redis"},{"location":"message-queue/#database-message-queue-pdo","text":"Create the database table","title":"Database Message Queue (PDO)"},{"location":"message-queue/#mysql","text":"CREATE TABLE queue ( id MEDIUMINT NOT NULL AUTO_INCREMENT, body TEXT, queue VARCHAR(100) NOT NULL, scheduled DATETIME NOT NULL, created_at DATETIME DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (id) );","title":"MySQL"},{"location":"message-queue/#sqlite","text":"CREATE TABLE queue ( id INTEGER PRIMARY KEY AUTOINCREMENT, body TEXT NOT NULL, queue TEXT NOT NULL, scheduled DATETIME NOT NULL, created_at DATETIME DEFAULT CURRENT_TIMESTAMP );","title":"Sqlite"},{"location":"message-queue/#postgres","text":"With Postgres , serialized PHP objects might have null byte characters such as when using private properties, this becomes a problem for Postgres as the data would have to be BYTEA and not a string. Therefore when using Postgres as the backend, the serialized string will be encoded/decoded with base64 , so either avoid private properties or create custome serialization which encodes/decodes the object. CREATE TABLE queue ( id SERIAL PRIMARY KEY, body TEXT, queue VARCHAR(100) NOT NULL, scheduled TIMESTAMP(0) NOT NULL, created_at TIMESTAMP(0) DEFAULT CURRENT_TIMESTAMP );","title":"Postgres"},{"location":"migration/","text":"Migrations Lightweight database migrations component. Usage Create the migrations table CREATE TABLE migrations ( id MEDIUMINT NOT NULL AUTO_INCREMENT, version BIGINT NOT NULL, created_at DATETIME DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (id) ); Create the Migration object passing a PDO connection and the path where your migrations will be. The PDO connection should throw an Exception if the query is invalid $pdo = new PDO('mysql:host=127.0.0.1;port=3306;dbname=lightning', 'root', 'secret'); $migration = new Migration($pdo, __DIR__ '/database/migrations'); Create the following migration file database/migrations/v1_initial_setup.sql -- Up CREATE TABLE posts ( id int unsigned NOT NULL AUTO_INCREMENT, title varchar(50) DEFAULT NULL, body text, created_at datetime NOT NULL, updated_at datetime NOT NULL, PRIMARY KEY (id) ) ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci; -- Down DROP TABLE IF EXISTS posts; You can create another one database/migrations/v2_add_index_posts.sql -- Up CREATE INDEX idx_title ON posts (title); -- Down ALTER TABLE posts DROP INDEX idx_title; To upgrade your database $migration->up(); // Use a callback to get current migration being run $migration->up(function($payload){ echo $payload['name']; var_dump($payload['statements']); }); To downgrade your database one level $migration->down(); // Use a callback to get current migration being run $migration->down(function($payload){ echo $payload['name']; var_dump($payload['statements']); });","title":"Migration"},{"location":"migration/#migrations","text":"Lightweight database migrations component.","title":"Migrations"},{"location":"migration/#usage","text":"Create the migrations table CREATE TABLE migrations ( id MEDIUMINT NOT NULL AUTO_INCREMENT, version BIGINT NOT NULL, created_at DATETIME DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (id) ); Create the Migration object passing a PDO connection and the path where your migrations will be. The PDO connection should throw an Exception if the query is invalid $pdo = new PDO('mysql:host=127.0.0.1;port=3306;dbname=lightning', 'root', 'secret'); $migration = new Migration($pdo, __DIR__ '/database/migrations'); Create the following migration file database/migrations/v1_initial_setup.sql -- Up CREATE TABLE posts ( id int unsigned NOT NULL AUTO_INCREMENT, title varchar(50) DEFAULT NULL, body text, created_at datetime NOT NULL, updated_at datetime NOT NULL, PRIMARY KEY (id) ) ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci; -- Down DROP TABLE IF EXISTS posts; You can create another one database/migrations/v2_add_index_posts.sql -- Up CREATE INDEX idx_title ON posts (title); -- Down ALTER TABLE posts DROP INDEX idx_title; To upgrade your database $migration->up(); // Use a callback to get current migration being run $migration->up(function($payload){ echo $payload['name']; var_dump($payload['statements']); }); To downgrade your database one level $migration->down(); // Use a callback to get current migration being run $migration->down(function($payload){ echo $payload['name']; var_dump($payload['statements']); });","title":"Usage"},{"location":"orm/","text":"ORM (Object Relational Mapper) The Object Relational Mapper extends the DataMapper to work with related data, this provides hasOne , hasMany , belongsTo and belongsToMany associations. Usage Lets create an Author model which has many Articles . class Author extends AbstractObjectRelationalMapper { protected string $table = 'authors'; protected array $fields = [ 'id', 'name', 'created_at','updated_at' ]; protected array $hasMany = [ [ 'className' => Article::class, 'foreignKey' => 'author_id', // in other table, 'dependent' => true, 'propertyName' => 'articles' ] ]; } Now define the Article class class Article extends AbstractObjectRelationalMapper { protected string $table = 'articles'; protected array $fields = [ 'id', 'title','body','author_id','created_at','updated_at' ]; protected array $belongsTo = [ [ 'className' => Author::class, 'foreignKey' => 'author_id', 'propertyName' => 'author' ] ]; } $result = $article->findBy(['id'=>1000], ['with'=> ['author']]); The related Author is added to the Article [ 'id' => 1000 'title' => 'Article #1' 'body' => 'A description for article #1' 'author_id' => 2000 'created_at' => '2021-10-03 09:01:00' 'updated_at' => '2021-10-03 09:02:00' 'author' => [ 'id' => 2000 'name' => 'Jon' 'created_at' => '2021-10-03 14:01:00' 'updated_at' => '2021-10-03 14:02:00' ] ] Associations Has One (one-to-one) The hasOne association is a one-to-one relationship, for example: a user has one profile. The foreign key is in the other table, so the profiles table has the column user_id . The following options are supported: - className: class for the Object Relational Mapper - propertyName: the name of the property where the data will be set - foreignKey: the name of the foreign key in the other table - dependent: When set to true associated records will also be deleted - fields: An array of fields to select, if not provided it will use the Data Mapper default - conditions: An array of additional criteria to use. e.g. ['tenant_id' => TENANT_ID] Has Many (one-to-many) The hasMany association is one-to-many relationship, for example: a user has many contacts. The foreign key is in the other table, so the contacts table has the column user_id . The following options are supported: - className: class for the Object Relational Mapper - propertyName: the name of the property where the data will be set - foreignKey: the name of the foreign key in the other table - dependent: When set to true associated records will also be deleted - fields: An array of fields to select, if not provided it will use the Data Mapper default - conditions: An array of additional criteria to use. e.g. ['tenant_id' => TENANT_ID] - order: A setting for order e.g. status DESC BelongsTo (many-to-one) The belongsTo association is a many-to-one relationship, for example: many contacts belong to a user. The foreign key is in the current table, so the contacts table has the column user_id . className: class for the Object Relational Mappe propertyName: the name of the property where the data will be set foreignKey: the name of the foreign key in the current table fields: An array of fields to select, if not provided it will use the Data Mapper default conditions: An array of additional criteria to use. e.g. ['tenant_id' => TENANT_ID] BelongsToMany (many-to-many) The belongsToMany association is a many-to-many relationship, for example: tags belongs to many articles, and articles belongs to many tags. This is handled by a special join table CREATE TABLE `posts_tags` ( `post_id` int(11) NOT NULL, `tag_id` int(11) NOT NULL, PRIMARY KEY (`post_id`,`tag_id`) ); The following options are supported: - className: class for the Object Relational Mapper - propertyName: the name of the property where the data will be set - joinTable: the name of the join table - foreignKey: the name of the foreign key used by this Data Mapper - otherForeignKey: the name of the foreign key used by the other Data Mapper - dependent: When set to true related records from the join table will be deleted - fields: An array of fields to select, if not provided it will use the Data Mapper default - conditions: An array of additional criteria to use. e.g. ['tenant_id' => TENANT_ID] - order: A setting for order e.g. status DESC MapperManager The MapperManager is responsible for managing the data mapper instances and creating them when needed, ensuring that there is only one instance ever created and that mappers are available in any direction. To create the Manager in your DI container $manager = new MapperManager($dataSource); If you are adding additional depenendices to the constructor or using a different datasource with a particular mapper, then you will need to either configure how the DataMapper is created or add an already created one. To add an already created one $manager->add(new ArticleMapper(new MemoryDataSource())); To create one when it is needed aka lazy load, you can use a factory callable. $manager->configure(ArticleMapper::class, function(DataSourceInterface $dataSource, EventDispatcherInterface $eventDispatcher, MapperManager $manager){ return new ArticleMapper($dataSource, $eventDispatcher, $manager, new SomeDependency()); }); Resources ORM Hate","title":"ORM (Object Relational Mapper)"},{"location":"orm/#orm-object-relational-mapper","text":"The Object Relational Mapper extends the DataMapper to work with related data, this provides hasOne , hasMany , belongsTo and belongsToMany associations.","title":"ORM (Object Relational Mapper)"},{"location":"orm/#usage","text":"Lets create an Author model which has many Articles . class Author extends AbstractObjectRelationalMapper { protected string $table = 'authors'; protected array $fields = [ 'id', 'name', 'created_at','updated_at' ]; protected array $hasMany = [ [ 'className' => Article::class, 'foreignKey' => 'author_id', // in other table, 'dependent' => true, 'propertyName' => 'articles' ] ]; } Now define the Article class class Article extends AbstractObjectRelationalMapper { protected string $table = 'articles'; protected array $fields = [ 'id', 'title','body','author_id','created_at','updated_at' ]; protected array $belongsTo = [ [ 'className' => Author::class, 'foreignKey' => 'author_id', 'propertyName' => 'author' ] ]; } $result = $article->findBy(['id'=>1000], ['with'=> ['author']]); The related Author is added to the Article [ 'id' => 1000 'title' => 'Article #1' 'body' => 'A description for article #1' 'author_id' => 2000 'created_at' => '2021-10-03 09:01:00' 'updated_at' => '2021-10-03 09:02:00' 'author' => [ 'id' => 2000 'name' => 'Jon' 'created_at' => '2021-10-03 14:01:00' 'updated_at' => '2021-10-03 14:02:00' ] ]","title":"Usage"},{"location":"orm/#associations","text":"","title":"Associations"},{"location":"orm/#has-one-one-to-one","text":"The hasOne association is a one-to-one relationship, for example: a user has one profile. The foreign key is in the other table, so the profiles table has the column user_id . The following options are supported: - className: class for the Object Relational Mapper - propertyName: the name of the property where the data will be set - foreignKey: the name of the foreign key in the other table - dependent: When set to true associated records will also be deleted - fields: An array of fields to select, if not provided it will use the Data Mapper default - conditions: An array of additional criteria to use. e.g. ['tenant_id' => TENANT_ID]","title":"Has One (one-to-one)"},{"location":"orm/#has-many-one-to-many","text":"The hasMany association is one-to-many relationship, for example: a user has many contacts. The foreign key is in the other table, so the contacts table has the column user_id . The following options are supported: - className: class for the Object Relational Mapper - propertyName: the name of the property where the data will be set - foreignKey: the name of the foreign key in the other table - dependent: When set to true associated records will also be deleted - fields: An array of fields to select, if not provided it will use the Data Mapper default - conditions: An array of additional criteria to use. e.g. ['tenant_id' => TENANT_ID] - order: A setting for order e.g. status DESC","title":"Has Many (one-to-many)"},{"location":"orm/#belongsto-many-to-one","text":"The belongsTo association is a many-to-one relationship, for example: many contacts belong to a user. The foreign key is in the current table, so the contacts table has the column user_id . className: class for the Object Relational Mappe propertyName: the name of the property where the data will be set foreignKey: the name of the foreign key in the current table fields: An array of fields to select, if not provided it will use the Data Mapper default conditions: An array of additional criteria to use. e.g. ['tenant_id' => TENANT_ID]","title":"BelongsTo (many-to-one)"},{"location":"orm/#belongstomany-many-to-many","text":"The belongsToMany association is a many-to-many relationship, for example: tags belongs to many articles, and articles belongs to many tags. This is handled by a special join table CREATE TABLE `posts_tags` ( `post_id` int(11) NOT NULL, `tag_id` int(11) NOT NULL, PRIMARY KEY (`post_id`,`tag_id`) ); The following options are supported: - className: class for the Object Relational Mapper - propertyName: the name of the property where the data will be set - joinTable: the name of the join table - foreignKey: the name of the foreign key used by this Data Mapper - otherForeignKey: the name of the foreign key used by the other Data Mapper - dependent: When set to true related records from the join table will be deleted - fields: An array of fields to select, if not provided it will use the Data Mapper default - conditions: An array of additional criteria to use. e.g. ['tenant_id' => TENANT_ID] - order: A setting for order e.g. status DESC","title":"BelongsToMany (many-to-many)"},{"location":"orm/#mappermanager","text":"The MapperManager is responsible for managing the data mapper instances and creating them when needed, ensuring that there is only one instance ever created and that mappers are available in any direction. To create the Manager in your DI container $manager = new MapperManager($dataSource); If you are adding additional depenendices to the constructor or using a different datasource with a particular mapper, then you will need to either configure how the DataMapper is created or add an already created one. To add an already created one $manager->add(new ArticleMapper(new MemoryDataSource())); To create one when it is needed aka lazy load, you can use a factory callable. $manager->configure(ArticleMapper::class, function(DataSourceInterface $dataSource, EventDispatcherInterface $eventDispatcher, MapperManager $manager){ return new ArticleMapper($dataSource, $eventDispatcher, $manager, new SomeDependency()); });","title":"MapperManager"},{"location":"orm/#resources","text":"ORM Hate","title":"Resources"},{"location":"params/","text":"Params Object The Params object is for passing parameters and working a set of parameters to an object which can be used, contracted etc. If get is called and the parameter was not supplied it will throw UnkownParameterException , therefore, for optional parameters check with has first. $params = new Params(['name' => 'fred', 'email' => 'fred@example.com']); $name = $params->get('name'); $bool = $params->has('surname');","title":"Params Object"},{"location":"params/#params-object","text":"The Params object is for passing parameters and working a set of parameters to an object which can be used, contracted etc. If get is called and the parameter was not supplied it will throw UnkownParameterException , therefore, for optional parameters check with has first. $params = new Params(['name' => 'fred', 'email' => 'fred@example.com']); $name = $params->get('name'); $bool = $params->has('surname');","title":"Params Object"},{"location":"query-builder/","text":"Query Builder An SQL query builder that uses arrays to create select, insert, update and delete statements. Usage Create the SQL Builder object. $builder = new QueryBuilder(); // don't quote tables and columns etc $builder = new QueryBuilder('`'); // quote for MySQL $builder = new QueryBuilder('\"'); // quote for postgres or sqlite Select Statement To start a SELECT query, call the select method, this will reset the query $builder->select(['*']) ->from('articles') ->where(['status' => 'published']); $sql = $builder->toString(); // Gets the SQL statement e.g. SELECT * FROM articles WHERE status = :v1 $params = $builder->getParams(); // Gets an array of params [':v1' => 'published'] Conditions The where method accepts an array of conditions. $builder->select(['*']) ->from('articles') ->where([ 'published' => 1, // Equals or if you pass a null value then it will be IS NULL 'author <>' => 1234] // Not equals or you can use != which is non ISO standard, 'deleted_at <>' => null, // IS NOT NULL 'status' => ['new','pending'], // IN 'category <>' => ['Development'], // NOT IN 'created_at BETWEEN' => ['2021-01-01 12:00:00', '2021-06-01 12:00:00'], // BETWEEN OR NOT BETWEEN 'title LIKE' => '%foo', // LIKE or NOT LIKE 'id >=' 2000, // arithmetic operators <,>,<=,>= ]); By default when you call where all conditions are joined by AND if you want to start a new OR group $builder->select(['*']) ->from('articles') ->where(['status' => 'published']); ->or(['author' => 1234]); // Find status published or author = 1234 The array conditions can also use unlimited nested conditions, by using OR , AND , and NOT . So you can rewrite the query above using nested conditions like this: $builder->select(['*']) ->from('articles') ->where([ 'status' => 'published', 'OR' => [ 'author' => 1234 ] ]); Join To carry out a join query, you can call the join type method $builder->select(['*']) ->from('articles') ->leftJoin('authors', 'authors', ['articles.author_id = authors.id']) Group To create a GROUP BY query $builder->select(['COUNT(*) AS count','category']) ->from('articles') ->groupBy('category'); Order $builder->select(['*']) ->from('articles') ->orderBy('id DESC'); Having $builder->select(['id', 'name','email']) ->from('articles') ->having('COUNT(id) > 5'); Limit To limit records $builder->select(['id', 'name','email']) ->from('articles') ->limit(10); To limit records starting from an offset $builder->select(['id', 'name','email']) ->from('articles') ->limit(10, 20);","title":"QueryBuilder"},{"location":"query-builder/#query-builder","text":"An SQL query builder that uses arrays to create select, insert, update and delete statements.","title":"Query Builder"},{"location":"query-builder/#usage","text":"Create the SQL Builder object. $builder = new QueryBuilder(); // don't quote tables and columns etc $builder = new QueryBuilder('`'); // quote for MySQL $builder = new QueryBuilder('\"'); // quote for postgres or sqlite","title":"Usage"},{"location":"query-builder/#select-statement","text":"To start a SELECT query, call the select method, this will reset the query $builder->select(['*']) ->from('articles') ->where(['status' => 'published']); $sql = $builder->toString(); // Gets the SQL statement e.g. SELECT * FROM articles WHERE status = :v1 $params = $builder->getParams(); // Gets an array of params [':v1' => 'published']","title":"Select Statement"},{"location":"query-builder/#conditions","text":"The where method accepts an array of conditions. $builder->select(['*']) ->from('articles') ->where([ 'published' => 1, // Equals or if you pass a null value then it will be IS NULL 'author <>' => 1234] // Not equals or you can use != which is non ISO standard, 'deleted_at <>' => null, // IS NOT NULL 'status' => ['new','pending'], // IN 'category <>' => ['Development'], // NOT IN 'created_at BETWEEN' => ['2021-01-01 12:00:00', '2021-06-01 12:00:00'], // BETWEEN OR NOT BETWEEN 'title LIKE' => '%foo', // LIKE or NOT LIKE 'id >=' 2000, // arithmetic operators <,>,<=,>= ]); By default when you call where all conditions are joined by AND if you want to start a new OR group $builder->select(['*']) ->from('articles') ->where(['status' => 'published']); ->or(['author' => 1234]); // Find status published or author = 1234 The array conditions can also use unlimited nested conditions, by using OR , AND , and NOT . So you can rewrite the query above using nested conditions like this: $builder->select(['*']) ->from('articles') ->where([ 'status' => 'published', 'OR' => [ 'author' => 1234 ] ]);","title":"Conditions"},{"location":"query-builder/#join","text":"To carry out a join query, you can call the join type method $builder->select(['*']) ->from('articles') ->leftJoin('authors', 'authors', ['articles.author_id = authors.id'])","title":"Join"},{"location":"query-builder/#group","text":"To create a GROUP BY query $builder->select(['COUNT(*) AS count','category']) ->from('articles') ->groupBy('category');","title":"Group"},{"location":"query-builder/#order","text":"$builder->select(['*']) ->from('articles') ->orderBy('id DESC');","title":"Order"},{"location":"query-builder/#having","text":"$builder->select(['id', 'name','email']) ->from('articles') ->having('COUNT(id) > 5');","title":"Having"},{"location":"query-builder/#limit","text":"To limit records $builder->select(['id', 'name','email']) ->from('articles') ->limit(10); To limit records starting from an offset $builder->select(['id', 'name','email']) ->from('articles') ->limit(10, 20);","title":"Limit"},{"location":"query/","text":"Query A Lightweight Query builder and statement executor. Usage Create the PDO object, it is best to set the error mode to exception mode. $pdo = new PDO('mysql:host=mysql;port=3306;dbname=lightning','root', 'root', [ PDO::ATTR_EMULATE_PREPARES => false, PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION ]); $query new Query($pdo, new SqlBuilder()); To load the first record that matches the criteria $article = $query->select(['id','title','created_at','updated_at']) ->from('articles') ->where(['id' => 1234]) ->first(); To load all the records $articles = $query->select(['id','title','created_at','updated_at']) ->from('articles') ->where(['status' => 'published']) ->or(['created_at <' => '2021-10-21 09:00:00']) ->all(); Select To start a SELECT query, call the select method, this will reset the query $query->select(['*']) ->from('articles') ->where(['status' => 'published']); Conditions The where method accepts an array of conditions. $query->select(['*']) ->from('articles') ->where([ 'published' => 1, // Equals or if you pass a null value then it will be IS NULL 'author <>' => 1234] // Not equals or you can use != which is non ISO standard, 'deleted_at <>' => null, // IS NOT NULL 'status' => ['new','pending'], // IN 'category <>' => ['Development'], // NOT IN 'created_at BETWEEN' => ['2021-01-01 12:00:00', '2021-06-01 12:00:00'], // BETWEEN OR NOT BETWEEN 'title LIKE' => '%foo', // LIKE or NOT LIKE 'id >=' 2000, // arithmetic operators <,>,<=,>= ]); The array conditions can also use nested conditions if they have the key OR , AND , this will join conditions by this type By default when you call where all conditions are joined by AND if you want to start a new group $query->select(['*']) ->from('articles') ->where(['status' => 'published']); ->or(['author' => 1234]); // Find status published or author = 1234 Join When you join records, data from each joined table is put in their own Row object. $result = $query->select(['*']) ->from('articles') ->leftJoin('authors','author', ['articles.author_id = author.id']) ->first(); echo $result->title; // article title echo $result->author->name; // the information from the table authors is in its own property To do multiple joins on the same table, use the aliases $result = $query->select(['articles.id','title','author.id','author.name']) ->from('articles') ->leftJoin('authors','author', ['articles.author_id = author.id']) ->leftJoin('authors','owner', ['articles.owner_id = owner.id']) ->first(); echo $result->author->name; echo $result->owner->name; When using Postgres or Sqlite with table aliases you must supply the column names, you cannot use wildcard * Group To create a GROUP BY query $query->select(['COUNT(*) AS count','category']) ->from('articles') ->groupBy('category'); Order $query->select(['*']) ->from('articles') ->orderBy('id DESC'); // or ['id' => 'DESC'] Having $query->select(['id', 'name','email']) ->from('articles') ->having('COUNT(id) > 5'); Limit To limit records $query->select(['id', 'name','email']) ->from('articles') ->limit(10); To limit records starting from an offset $query->select(['id', 'name','email']) ->from('articles') ->limit(10, 20); Paging You can also use page which automatically calculates the limit, offset for you. $query->select(['*']) ->from('articles') ->page(5, 20) Insert Statement To insert records $query->insertInto('posts') ->values([ 'title' => 'This is an article', 'body' => 'Some article body', 'created_at' => '2021-10-23 15:35:00', 'updated_at' => '2021-10-23 15:35:00', ]) ->execute(); To get the last insert ID $id = $query->getLastInsertId(); Update Statement To update data in the database, the execute method will return the number of rows affected. $rowsAffected = $query->update('posts') ->set([ 'title' => 'foo' ]) ->where(['id' => 1000]) ->execute(); Delete Statement To delete data in the database, the execute method will return the number of rows affected. $rowsAffected = $query->deleteFrom('posts') ->where(['id' => 1000]); ->execute();","title":"Query"},{"location":"query/#query","text":"A Lightweight Query builder and statement executor.","title":"Query"},{"location":"query/#usage","text":"Create the PDO object, it is best to set the error mode to exception mode. $pdo = new PDO('mysql:host=mysql;port=3306;dbname=lightning','root', 'root', [ PDO::ATTR_EMULATE_PREPARES => false, PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION ]); $query new Query($pdo, new SqlBuilder()); To load the first record that matches the criteria $article = $query->select(['id','title','created_at','updated_at']) ->from('articles') ->where(['id' => 1234]) ->first(); To load all the records $articles = $query->select(['id','title','created_at','updated_at']) ->from('articles') ->where(['status' => 'published']) ->or(['created_at <' => '2021-10-21 09:00:00']) ->all();","title":"Usage"},{"location":"query/#select","text":"To start a SELECT query, call the select method, this will reset the query $query->select(['*']) ->from('articles') ->where(['status' => 'published']);","title":"Select"},{"location":"query/#conditions","text":"The where method accepts an array of conditions. $query->select(['*']) ->from('articles') ->where([ 'published' => 1, // Equals or if you pass a null value then it will be IS NULL 'author <>' => 1234] // Not equals or you can use != which is non ISO standard, 'deleted_at <>' => null, // IS NOT NULL 'status' => ['new','pending'], // IN 'category <>' => ['Development'], // NOT IN 'created_at BETWEEN' => ['2021-01-01 12:00:00', '2021-06-01 12:00:00'], // BETWEEN OR NOT BETWEEN 'title LIKE' => '%foo', // LIKE or NOT LIKE 'id >=' 2000, // arithmetic operators <,>,<=,>= ]); The array conditions can also use nested conditions if they have the key OR , AND , this will join conditions by this type By default when you call where all conditions are joined by AND if you want to start a new group $query->select(['*']) ->from('articles') ->where(['status' => 'published']); ->or(['author' => 1234]); // Find status published or author = 1234","title":"Conditions"},{"location":"query/#join","text":"When you join records, data from each joined table is put in their own Row object. $result = $query->select(['*']) ->from('articles') ->leftJoin('authors','author', ['articles.author_id = author.id']) ->first(); echo $result->title; // article title echo $result->author->name; // the information from the table authors is in its own property To do multiple joins on the same table, use the aliases $result = $query->select(['articles.id','title','author.id','author.name']) ->from('articles') ->leftJoin('authors','author', ['articles.author_id = author.id']) ->leftJoin('authors','owner', ['articles.owner_id = owner.id']) ->first(); echo $result->author->name; echo $result->owner->name; When using Postgres or Sqlite with table aliases you must supply the column names, you cannot use wildcard *","title":"Join"},{"location":"query/#group","text":"To create a GROUP BY query $query->select(['COUNT(*) AS count','category']) ->from('articles') ->groupBy('category');","title":"Group"},{"location":"query/#order","text":"$query->select(['*']) ->from('articles') ->orderBy('id DESC'); // or ['id' => 'DESC']","title":"Order"},{"location":"query/#having","text":"$query->select(['id', 'name','email']) ->from('articles') ->having('COUNT(id) > 5');","title":"Having"},{"location":"query/#limit","text":"To limit records $query->select(['id', 'name','email']) ->from('articles') ->limit(10); To limit records starting from an offset $query->select(['id', 'name','email']) ->from('articles') ->limit(10, 20);","title":"Limit"},{"location":"query/#paging","text":"You can also use page which automatically calculates the limit, offset for you. $query->select(['*']) ->from('articles') ->page(5, 20)","title":"Paging"},{"location":"query/#insert-statement","text":"To insert records $query->insertInto('posts') ->values([ 'title' => 'This is an article', 'body' => 'Some article body', 'created_at' => '2021-10-23 15:35:00', 'updated_at' => '2021-10-23 15:35:00', ]) ->execute(); To get the last insert ID $id = $query->getLastInsertId();","title":"Insert Statement"},{"location":"query/#update-statement","text":"To update data in the database, the execute method will return the number of rows affected. $rowsAffected = $query->update('posts') ->set([ 'title' => 'foo' ]) ->where(['id' => 1000]) ->execute();","title":"Update Statement"},{"location":"query/#delete-statement","text":"To delete data in the database, the execute method will return the number of rows affected. $rowsAffected = $query->deleteFrom('posts') ->where(['id' => 1000]); ->execute();","title":"Delete Statement"},{"location":"repository/","text":"Repository (concept) This is an additional layer over the DataMapper . Usage $pdo = new PDO('mysql:host=mysql;port=3306;dbname=lightning','root', 'root'); $dataSource = new DatabaseDataSource($pdo, new QueryBuilder()); $repository = new UserRepository( new UserMapper($dataSource));","title":"Repository"},{"location":"repository/#repository-concept","text":"This is an additional layer over the DataMapper .","title":"Repository (concept)"},{"location":"repository/#usage","text":"$pdo = new PDO('mysql:host=mysql;port=3306;dbname=lightning','root', 'root'); $dataSource = new DatabaseDataSource($pdo, new QueryBuilder()); $repository = new UserRepository( new UserMapper($dataSource));","title":"Usage"},{"location":"router/","text":"Lightning Router A lightweight PSR-7 and PSR-15 router with support for PSR-11, PSR-14. Usage Create the Router object then dispatch with the ServerRequestInterface request. $router = new Router(); $router->get('/articles/index', function (ServerRequestInterface $request) { $response = new Response(); $response->getBody()->write(json_encode(['foo'=>'bar'])); return $response->withStatus(200); }); $router->dispatch($request); // Psr\\Http\\Message\\ServerRequestInterface To configure a route to use a callable $router->get('/articles', [new ArticlesController, 'index']); $router->get('/articles/home', ArticlesHomeController::class); You can also use proxies which will create the callable , and if you created the router with a PSR-11 Container then it will use this to create the object, if its available in Container . $router->get('/articles/index', 'App\\Controller\\ArticlesController::index'); $router->get('/articles/index', [ArticlesController::class, 'index']); $router->get('/articles/index', ArticlesIndexController::class); // __invoke method Method arguments By default the ServerRequestInterface object will be passed to the callable , and if you created the Router with a blank ResponseInterface object this will be passed as a second argument. class ArticlesController { public function show(ServerRequestInterface $request) : ResponseInterface { $id = (int) $request->getAttribute('id'); $response = new Response(); $response->getBody()->write(\"<h1>Articles <small>{$id}</small></h1>\"); return $response->withStatus(200); } } URL Variables When you need to get a value from the URL $router->get('/articles/:id', 'App\\Controller\\ArticlesController::show'); This will be added to the `ServerRequestInterface object. $id = (int) $request->getAttribute('id') For security you can make sure that the data that is being passed matches a regular expression pattern. Note: #^ and $# will be added automatically. $router->delete('/articles/:id', 'App\\Controller\\ArticlesController::delete',[ 'id' => '[0-9]{1,20}' ]); Route Groups You can group your route definitions together, these routes will only be processed if there is a match on the prefix. $router->group('/admin', function (RoutesInterface $routes) { $routes->get('/dashboard', 'App\\Controller\\AdminController::dashboard'); // GET /admin/dashboard }); Middleware To add Middleware on all routes $router->middleware(new FooMiddleware); To add a Middleware to the start of the queue $router->prependMiddleware(new FooMiddleware); To add for an individual Route $router->get('/articles', [new ArticlesController,'index'])->middleware(new AuthMiddleware); To add Middleware for all Routes in a group. $router->group('/admin', function (RoutesInterface $routes) { $routes->get('/dashboard', 'App\\Controller\\AdminController::dashboard'); // GET /admin/dashboard })->middleware(new AuthMiddleware); Resources Here is an example for reference on a sample configuration $router->get('/articles/new', [ArticlesController::class,'new']); $router->get('articles', [ArticlesController::class,'index']); $router->post('articles', [ArticlesController::class,'create']); $router->get('/articles/:id/edit', [ArticlesController::class,'edit'], ['id' => '[0-9]+']); $router->get('/articles/:id', [ArticlesController::class,'show'], ['id' => '[0-9]+']); $router->patch('/articles/:id', [ArticlesController::class,'update'], ['id' => '[0-9]+']); $router->delete('/articles/:id', [ArticlesController::class,'destroy'], ['id' => '[0-9]+']); PSR-11: DI Container When creating the Router object add a Container object to use when creating the object from the matched route proxy. Autowiring You can also use autowiring of methods or closures, simply supply the Autowire object when creating the Router object. ControllerInterface You can add the ControllerInterface add life cycle callbacks to your Controller which will be called before and after the action is invoked. class ArticlesController implements ControllerInterface { public function beforeFilter(ServerRequestInterface $request): ?ResponseInterface { $this->request = $request; return $this->eventDispatcher->dispatch(new BeforeFilterEvent($request))->getResponse(); // Response object or null } public function afterFilter(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface { return $this->eventDispatcher->dispatch(new AfterFilterEvent($request, $response))->getResponse(); // Response object } }","title":"Router"},{"location":"router/#lightning-router","text":"A lightweight PSR-7 and PSR-15 router with support for PSR-11, PSR-14.","title":"Lightning Router"},{"location":"router/#usage","text":"Create the Router object then dispatch with the ServerRequestInterface request. $router = new Router(); $router->get('/articles/index', function (ServerRequestInterface $request) { $response = new Response(); $response->getBody()->write(json_encode(['foo'=>'bar'])); return $response->withStatus(200); }); $router->dispatch($request); // Psr\\Http\\Message\\ServerRequestInterface To configure a route to use a callable $router->get('/articles', [new ArticlesController, 'index']); $router->get('/articles/home', ArticlesHomeController::class); You can also use proxies which will create the callable , and if you created the router with a PSR-11 Container then it will use this to create the object, if its available in Container . $router->get('/articles/index', 'App\\Controller\\ArticlesController::index'); $router->get('/articles/index', [ArticlesController::class, 'index']); $router->get('/articles/index', ArticlesIndexController::class); // __invoke method","title":"Usage"},{"location":"router/#method-arguments","text":"By default the ServerRequestInterface object will be passed to the callable , and if you created the Router with a blank ResponseInterface object this will be passed as a second argument. class ArticlesController { public function show(ServerRequestInterface $request) : ResponseInterface { $id = (int) $request->getAttribute('id'); $response = new Response(); $response->getBody()->write(\"<h1>Articles <small>{$id}</small></h1>\"); return $response->withStatus(200); } }","title":"Method arguments"},{"location":"router/#url-variables","text":"When you need to get a value from the URL $router->get('/articles/:id', 'App\\Controller\\ArticlesController::show'); This will be added to the `ServerRequestInterface object. $id = (int) $request->getAttribute('id') For security you can make sure that the data that is being passed matches a regular expression pattern. Note: #^ and $# will be added automatically. $router->delete('/articles/:id', 'App\\Controller\\ArticlesController::delete',[ 'id' => '[0-9]{1,20}' ]);","title":"URL Variables"},{"location":"router/#route-groups","text":"You can group your route definitions together, these routes will only be processed if there is a match on the prefix. $router->group('/admin', function (RoutesInterface $routes) { $routes->get('/dashboard', 'App\\Controller\\AdminController::dashboard'); // GET /admin/dashboard });","title":"Route Groups"},{"location":"router/#middleware","text":"To add Middleware on all routes $router->middleware(new FooMiddleware); To add a Middleware to the start of the queue $router->prependMiddleware(new FooMiddleware); To add for an individual Route $router->get('/articles', [new ArticlesController,'index'])->middleware(new AuthMiddleware); To add Middleware for all Routes in a group. $router->group('/admin', function (RoutesInterface $routes) { $routes->get('/dashboard', 'App\\Controller\\AdminController::dashboard'); // GET /admin/dashboard })->middleware(new AuthMiddleware);","title":"Middleware"},{"location":"router/#resources","text":"Here is an example for reference on a sample configuration $router->get('/articles/new', [ArticlesController::class,'new']); $router->get('articles', [ArticlesController::class,'index']); $router->post('articles', [ArticlesController::class,'create']); $router->get('/articles/:id/edit', [ArticlesController::class,'edit'], ['id' => '[0-9]+']); $router->get('/articles/:id', [ArticlesController::class,'show'], ['id' => '[0-9]+']); $router->patch('/articles/:id', [ArticlesController::class,'update'], ['id' => '[0-9]+']); $router->delete('/articles/:id', [ArticlesController::class,'destroy'], ['id' => '[0-9]+']);","title":"Resources"},{"location":"router/#psr-11-di-container","text":"When creating the Router object add a Container object to use when creating the object from the matched route proxy.","title":"PSR-11: DI Container"},{"location":"router/#autowiring","text":"You can also use autowiring of methods or closures, simply supply the Autowire object when creating the Router object.","title":"Autowiring"},{"location":"router/#controllerinterface","text":"You can add the ControllerInterface add life cycle callbacks to your Controller which will be called before and after the action is invoked. class ArticlesController implements ControllerInterface { public function beforeFilter(ServerRequestInterface $request): ?ResponseInterface { $this->request = $request; return $this->eventDispatcher->dispatch(new BeforeFilterEvent($request))->getResponse(); // Response object or null } public function afterFilter(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface { return $this->eventDispatcher->dispatch(new AfterFilterEvent($request, $response))->getResponse(); // Response object } }","title":"ControllerInterface"},{"location":"service-object/","text":"Service Object Service objects help keep your models and controllers skinny, whilst keeping your code clean and testable. The service object also helps you seperate your application business logic from the framework and also makes it easy to test in isolation. Service Objects must have all dependencies added to the __constructor method. The Service Object is based upon the command pattern and follows the single responsibility principle , with the protected method execute where the application business logic goes and it must always return a ResultInterface object, standardizing the result is also an important part of this design. Usage Create a class with depdencies in the __construct method and place the busines logic in the execute method, which must return a ResultInterface object. class RegisterUserService extends AbstractServiceObject { public function __construct(private Model $user, private LoggerInterface $logger) { } protected function execute(Params $params) : Result { $user = $params->get('user'); if(!$user){ return new Result(false, ['message' =>'User not found']); } // do some stuff return new Result(true, ['user'=>$user]); } } To run the ServiceObject you can pass an array of parameters that will be passed as a Params object during execution, this is to ensure that state is not set during the constructor for DI purposes. $result = (new RegisterUserService ($model, $logger)) ->withParameters(['name' => 'fred', 'email' => 'fred@example.com']) ->run(); Result Object Depending what the service layer is doing sometimes you will need to just return a simple true or false and other times you will need a richer result. Some of the methods available on Result object: // check status $result->isSuccess(); $result->isError(); // work with data $result->hasData(); $result->getData(); $result->get('message'); $string = (string) $result; $result = $result->withSuccess(false); // $result = $result->withData(['key' => 'value']);","title":"Service Object"},{"location":"service-object/#service-object","text":"Service objects help keep your models and controllers skinny, whilst keeping your code clean and testable. The service object also helps you seperate your application business logic from the framework and also makes it easy to test in isolation. Service Objects must have all dependencies added to the __constructor method. The Service Object is based upon the command pattern and follows the single responsibility principle , with the protected method execute where the application business logic goes and it must always return a ResultInterface object, standardizing the result is also an important part of this design.","title":"Service Object"},{"location":"service-object/#usage","text":"Create a class with depdencies in the __construct method and place the busines logic in the execute method, which must return a ResultInterface object. class RegisterUserService extends AbstractServiceObject { public function __construct(private Model $user, private LoggerInterface $logger) { } protected function execute(Params $params) : Result { $user = $params->get('user'); if(!$user){ return new Result(false, ['message' =>'User not found']); } // do some stuff return new Result(true, ['user'=>$user]); } } To run the ServiceObject you can pass an array of parameters that will be passed as a Params object during execution, this is to ensure that state is not set during the constructor for DI purposes. $result = (new RegisterUserService ($model, $logger)) ->withParameters(['name' => 'fred', 'email' => 'fred@example.com']) ->run();","title":"Usage"},{"location":"service-object/#result-object","text":"Depending what the service layer is doing sometimes you will need to just return a simple true or false and other times you will need a richer result. Some of the methods available on Result object: // check status $result->isSuccess(); $result->isError(); // work with data $result->hasData(); $result->getData(); $result->get('message'); $string = (string) $result; $result = $result->withSuccess(false); // $result = $result->withData(['key' => 'value']);","title":"Result Object"},{"location":"template-renderer/","text":"Template Renderer To create a new TemplateRenderer object set the path of the templates folder and the path where the compiled templates can be saved. Usage Create a template in your views folder <?php /** * @var \\Lightning\\TemplateRenderer\\TemplateRenderer $this */ ?> <h1>Heading <small class=\"text-muted\">Secondary text</small></h1> To create the TemplateRenderer object pass the template folder and temporary folder where the compiled templates are stored. $templateRenderer = new TemplateRenderer('/var/www/resources/views'); $output = $templateRenderer->render('articles/index'); You can also pass variables to the TemplateRenderer $templateRenderer->render('articles/index', ['foo' => 'bar']); // To render a template using a specific file, make sure the template name starts with / $output = $templateRenderer->render('/var/www/resources/views/articles/index.php'); By default the TemplateRenderer caches the template compliation to the system temp directory, however if you to prefer to use somewhere else, then during the creation of the object set the cache path. $templateRenderer = new TemplateRenderer('/var/www/resources/views', '/var/www/tmp/views'); Layouts Create a template that you want to use as a layout, and make sure to echo the content variable. <!doctype html> <html lang=\"en\"> <head> <meta charset=\"utf-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"> <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-KyZXEAg3QhqLMpG8r+8fhAXLRk2vvoC2f3B09zVXn8CA5QIVfZOJ3BCsw2P0p/We\" crossorigin=\"anonymous\"> <title>Web Application</title> </head> <body> <?= $content ?> <script src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.bundle.min.js\" integrity=\"sha384-U1DAWAznBHeqEIlVSCgzq+c9gqGAJn5c/t99JyeKa9xxaYpSvHU5awsuZVVFIhvj\" crossorigin=\"anonymous\"></script> </body> </html> Now configure the TemplateRenderer to use the layout $output = $templateRenderer ->withLayout('layouts/app') // /var/www/resources/views/layouts/app.php ->render('articles/index'); Or you can set from within the template <?php $this->layout = 'layouts/books'; ?> <h1>{{ $book->author }}</h1> Partials You can also render a partial template (without a layout) from within the template <h1>{{ $book->author }}</h1> <?= $this->render('partials/book', ['book' => $book]) ?> Security You should pass all variables through the double curly brackets which will escape the output, to protect your application against against vulnerabilities such as XSS. <h1>{{ $book->author }}</h1> TemplateRenderer Attributes You can set attributes which are then accessible inside the template $templateRenderer->setAttribute('t', new Translator()); Then inside your TemplateRenderer <h1>{{ $t->translate('Users Home') }}</h1>","title":"Template Renderer"},{"location":"template-renderer/#template-renderer","text":"To create a new TemplateRenderer object set the path of the templates folder and the path where the compiled templates can be saved.","title":"Template Renderer"},{"location":"template-renderer/#usage","text":"Create a template in your views folder <?php /** * @var \\Lightning\\TemplateRenderer\\TemplateRenderer $this */ ?> <h1>Heading <small class=\"text-muted\">Secondary text</small></h1> To create the TemplateRenderer object pass the template folder and temporary folder where the compiled templates are stored. $templateRenderer = new TemplateRenderer('/var/www/resources/views'); $output = $templateRenderer->render('articles/index'); You can also pass variables to the TemplateRenderer $templateRenderer->render('articles/index', ['foo' => 'bar']); // To render a template using a specific file, make sure the template name starts with / $output = $templateRenderer->render('/var/www/resources/views/articles/index.php'); By default the TemplateRenderer caches the template compliation to the system temp directory, however if you to prefer to use somewhere else, then during the creation of the object set the cache path. $templateRenderer = new TemplateRenderer('/var/www/resources/views', '/var/www/tmp/views');","title":"Usage"},{"location":"template-renderer/#layouts","text":"Create a template that you want to use as a layout, and make sure to echo the content variable. <!doctype html> <html lang=\"en\"> <head> <meta charset=\"utf-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"> <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-KyZXEAg3QhqLMpG8r+8fhAXLRk2vvoC2f3B09zVXn8CA5QIVfZOJ3BCsw2P0p/We\" crossorigin=\"anonymous\"> <title>Web Application</title> </head> <body> <?= $content ?> <script src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.bundle.min.js\" integrity=\"sha384-U1DAWAznBHeqEIlVSCgzq+c9gqGAJn5c/t99JyeKa9xxaYpSvHU5awsuZVVFIhvj\" crossorigin=\"anonymous\"></script> </body> </html> Now configure the TemplateRenderer to use the layout $output = $templateRenderer ->withLayout('layouts/app') // /var/www/resources/views/layouts/app.php ->render('articles/index'); Or you can set from within the template <?php $this->layout = 'layouts/books'; ?> <h1>{{ $book->author }}</h1>","title":"Layouts"},{"location":"template-renderer/#partials","text":"You can also render a partial template (without a layout) from within the template <h1>{{ $book->author }}</h1> <?= $this->render('partials/book', ['book' => $book]) ?>","title":"Partials"},{"location":"template-renderer/#security","text":"You should pass all variables through the double curly brackets which will escape the output, to protect your application against against vulnerabilities such as XSS. <h1>{{ $book->author }}</h1>","title":"Security"},{"location":"template-renderer/#templaterenderer-attributes","text":"You can set attributes which are then accessible inside the template $templateRenderer->setAttribute('t', new Translator()); Then inside your TemplateRenderer <h1>{{ $t->translate('Users Home') }}</h1>","title":"TemplateRenderer Attributes"},{"location":"test-suite/","text":"Testsuite A PSR friendly test suite. Usage Add the IntegrationTestTrait to your test, you will need a PSR 17 Server Request and Response Factory implementation and a RequestHandler . You may need to create your own using your own router etc. use Lightning\\TestSuite\\RequestHandlerFactory; final class ArticlesControllerTest extends TestCase { use IntegrationTestTrait; public function setUp(): void { // Create DI Container $definitions = include dirname(__DIR__, 3) . '/config/services.php'; $container = new Container($definitions); $container->enableAutowiring() ->enableAutoConfiguration(); $requestHandler = $container->get(Router::class); // RequestHandlerInterface // Setup Integration testing $this->setupIntegrationTesting( new ServerRequestFactory(new Psr17ServerRequestFactory()), new Psr17ResponseFactory(), $requestHandler, new TestSession() ); } } Now in your tests you have a number of assertions public function testIndex() : void { $this->get('/articles/index'); $this->assertResponseCode(200); $this->assertResponseContains('<h1>Articles</h1>'); } For a test you might want to set the headers which will be added to the ServerRequestInterface request object $this->setHeaders([ 'PHP_AUTH_USER' => 'somebody@example.com' ]); To add Cookies to the ServerRequestInterface request object $this->setCookieParams([ 'user_id' => '1234' ]); You can also set $_SERVER vars which will be added to the ServerRequestInterface request object $this->setServerParams([ 'HTTP_REFERER' => 'https://www.google.co.uk' ]); If you are testing file uploads, add your UploadedFileInterface objects, this will be added to the ServerRequestInterface request object, so then getUploadedFiles works as expected. $this->setUploadedFiles([ 'image_upload' => new UploadedFile( '/var/www/tests/files/README.txt', 1024, UPLOAD_ERR_OK, 'README.txt', 'text/plain' ) ]); To set items in the Session , the default TestSession works with the $_SESSION variable. If you are using something else then you can use the TestSessionInterface to create your own. $this->setSession([ 'user_id' => 1234 ]); Testing Dispatched Events TestEventDispatcher The TestEventDispatcher is PSR 14 Event Dispatcher which is for testing wether Events where triggered or not. It comes with the additional methods $eventDispatcher = new TestEventDispatcher(new EventDispatcher); $events = $eventDispatcher->getDispatchedEvents(); // [BeforeFind::class] $event = $eventDispatcher->getDispatchedEvent(BeforeFind::class); $bool = $eventDispatcher->hasDispatchedEvent(BeforeFind::class); You can call $eventDispatcher->on(BeforeFind::class, function(BeforeFind $event){ $event->stop(); }) EventDispatcherTestTrait The EventDispatcherTestTrait makes easier to test dispatched events in applications. use EventDispatcherTestTraitTestTrait; public function setUp(): void { $dispatcher = $this->createEventDispatcher(); $this->setEventDispatcher($dispatcher); } public function testDoSomething(): void { $object = new SomeObject($this->getEventDispatcher()); $object->doSomething(); $this->assertEventDispatched(BeforeSomething::class); } The following methods are provided: $this->assertEventsDispatchedCount(5); $this->assertEventDispatched(BeforeSomething::class); $this->assertEventNotDispatched(BeforeSomething::class); // These check that events were or were not dispatched (regardless of order or other events being dispatched) $this->assertEventsDispatched([BeforeSomething::class]); $this->assertEventsNotDispatched([BeforeSomething::class]); // These check that only these events were/were not dispatched in this order $this->assertEventsDispatchedEquals([BeforeSomething::class]); $this->assertEventsDispatchedNotEquals([BeforeSomething::class]); Testing Logging TestLogger The TestLogger is a PSR logger event dispatcher which is for testing. It comes with two additional methods // Checks an exact message is in the log $bool = $testLogger->hasMessage('Invoice #355 was printed', LogLevel::DEBUG); // Checks the unrendered version $bool = $testLogger->hasMessage('Invoice #{number} was printed', LogLevel::DEBUG, false) // Check for a partial string in the log $bool = $testLogger->hasMessageThatContains('could not send email', LogLevel::ERROR); count($testLogger); // count the logged items // Check using regex $bool = $testLogger->hasMessageThatMatches('/could not send (sms|email)/', LogLevel::ERROR); count($testLogger); // count the logged items LoggerTestTrait The LoggerTestTrait provides various assertation methods, making it easier to test applications. use LoggerTestTrait; public function setUp(): void { $testLogger = $this->createLogger(); $this->setLogger($testLogger); } public function testDoSomething(): void { $object = new SomeObject($this->getLogger()); $object->doSomething(); $this->assertLogHasMessage('Could not do something', LogLevel::ERROR); } The following methods are provided: $this->assertLogHasMessage('Could not connect to SMTP server', LogLevel::ERROR); $this->assertLogHasMessageThatContains('SMTP server', LogLevel::ERROR); $this->assertLogHasMessageThatMatches('Error sending (email|sms)', LogLevel::ERROR); $this->assertLogDoesNotHaveMessage('Could not connect to SMTP server', LogLevel::ERROR); $this->assertLogDoesNotHaveMessageThatContains('SMTP server', LogLevel::ERROR); $this->assertLogDoesNotHaveMessageThatMatches('Error sending (email|sms)', LogLevel::ERROR); $this->assertLogMessagesCount(5); Testing Middleware The TestRequestHandler helps making it easy to test middleware in a consistent manner. public function testMiddleware(): void { $handler = new TestRequestHandler(new FooMiddleware(), new Response()) $response = $handler->dispatch( new ServerRequest('GET', '/')); // Do your checks } There is also a beforeHandle method which accepts a callback , here you can do prechecks $handler = new TestRequestHandler(new FooMiddleware(), new Response()) $handler->beforeHandle(function(ServerRequestInterface $request) use ($object){ $this->assertTrue($object->wasCalled()); }); $handler->dispatch(new ServerRequest('GET', '/')); You can also get the ServerRequestInterface object that was passed to the handle method, this is useful in situations where Middleware is modifying the request object. $handler->dispatch(new ServerRequest('GET', '/')); $this->assertEquals('bar',$handler->getRequest()->getAttribute('foo'));","title":"Test Suite"},{"location":"test-suite/#testsuite","text":"A PSR friendly test suite.","title":"Testsuite"},{"location":"test-suite/#usage","text":"Add the IntegrationTestTrait to your test, you will need a PSR 17 Server Request and Response Factory implementation and a RequestHandler . You may need to create your own using your own router etc. use Lightning\\TestSuite\\RequestHandlerFactory; final class ArticlesControllerTest extends TestCase { use IntegrationTestTrait; public function setUp(): void { // Create DI Container $definitions = include dirname(__DIR__, 3) . '/config/services.php'; $container = new Container($definitions); $container->enableAutowiring() ->enableAutoConfiguration(); $requestHandler = $container->get(Router::class); // RequestHandlerInterface // Setup Integration testing $this->setupIntegrationTesting( new ServerRequestFactory(new Psr17ServerRequestFactory()), new Psr17ResponseFactory(), $requestHandler, new TestSession() ); } } Now in your tests you have a number of assertions public function testIndex() : void { $this->get('/articles/index'); $this->assertResponseCode(200); $this->assertResponseContains('<h1>Articles</h1>'); } For a test you might want to set the headers which will be added to the ServerRequestInterface request object $this->setHeaders([ 'PHP_AUTH_USER' => 'somebody@example.com' ]); To add Cookies to the ServerRequestInterface request object $this->setCookieParams([ 'user_id' => '1234' ]); You can also set $_SERVER vars which will be added to the ServerRequestInterface request object $this->setServerParams([ 'HTTP_REFERER' => 'https://www.google.co.uk' ]); If you are testing file uploads, add your UploadedFileInterface objects, this will be added to the ServerRequestInterface request object, so then getUploadedFiles works as expected. $this->setUploadedFiles([ 'image_upload' => new UploadedFile( '/var/www/tests/files/README.txt', 1024, UPLOAD_ERR_OK, 'README.txt', 'text/plain' ) ]); To set items in the Session , the default TestSession works with the $_SESSION variable. If you are using something else then you can use the TestSessionInterface to create your own. $this->setSession([ 'user_id' => 1234 ]);","title":"Usage"},{"location":"test-suite/#testing-dispatched-events","text":"","title":"Testing Dispatched Events"},{"location":"test-suite/#testeventdispatcher","text":"The TestEventDispatcher is PSR 14 Event Dispatcher which is for testing wether Events where triggered or not. It comes with the additional methods $eventDispatcher = new TestEventDispatcher(new EventDispatcher); $events = $eventDispatcher->getDispatchedEvents(); // [BeforeFind::class] $event = $eventDispatcher->getDispatchedEvent(BeforeFind::class); $bool = $eventDispatcher->hasDispatchedEvent(BeforeFind::class); You can call $eventDispatcher->on(BeforeFind::class, function(BeforeFind $event){ $event->stop(); })","title":"TestEventDispatcher"},{"location":"test-suite/#eventdispatchertesttrait","text":"The EventDispatcherTestTrait makes easier to test dispatched events in applications. use EventDispatcherTestTraitTestTrait; public function setUp(): void { $dispatcher = $this->createEventDispatcher(); $this->setEventDispatcher($dispatcher); } public function testDoSomething(): void { $object = new SomeObject($this->getEventDispatcher()); $object->doSomething(); $this->assertEventDispatched(BeforeSomething::class); } The following methods are provided: $this->assertEventsDispatchedCount(5); $this->assertEventDispatched(BeforeSomething::class); $this->assertEventNotDispatched(BeforeSomething::class); // These check that events were or were not dispatched (regardless of order or other events being dispatched) $this->assertEventsDispatched([BeforeSomething::class]); $this->assertEventsNotDispatched([BeforeSomething::class]); // These check that only these events were/were not dispatched in this order $this->assertEventsDispatchedEquals([BeforeSomething::class]); $this->assertEventsDispatchedNotEquals([BeforeSomething::class]);","title":"EventDispatcherTestTrait"},{"location":"test-suite/#testing-logging","text":"","title":"Testing Logging"},{"location":"test-suite/#testlogger","text":"The TestLogger is a PSR logger event dispatcher which is for testing. It comes with two additional methods // Checks an exact message is in the log $bool = $testLogger->hasMessage('Invoice #355 was printed', LogLevel::DEBUG); // Checks the unrendered version $bool = $testLogger->hasMessage('Invoice #{number} was printed', LogLevel::DEBUG, false) // Check for a partial string in the log $bool = $testLogger->hasMessageThatContains('could not send email', LogLevel::ERROR); count($testLogger); // count the logged items // Check using regex $bool = $testLogger->hasMessageThatMatches('/could not send (sms|email)/', LogLevel::ERROR); count($testLogger); // count the logged items","title":"TestLogger"},{"location":"test-suite/#loggertesttrait","text":"The LoggerTestTrait provides various assertation methods, making it easier to test applications. use LoggerTestTrait; public function setUp(): void { $testLogger = $this->createLogger(); $this->setLogger($testLogger); } public function testDoSomething(): void { $object = new SomeObject($this->getLogger()); $object->doSomething(); $this->assertLogHasMessage('Could not do something', LogLevel::ERROR); } The following methods are provided: $this->assertLogHasMessage('Could not connect to SMTP server', LogLevel::ERROR); $this->assertLogHasMessageThatContains('SMTP server', LogLevel::ERROR); $this->assertLogHasMessageThatMatches('Error sending (email|sms)', LogLevel::ERROR); $this->assertLogDoesNotHaveMessage('Could not connect to SMTP server', LogLevel::ERROR); $this->assertLogDoesNotHaveMessageThatContains('SMTP server', LogLevel::ERROR); $this->assertLogDoesNotHaveMessageThatMatches('Error sending (email|sms)', LogLevel::ERROR); $this->assertLogMessagesCount(5);","title":"LoggerTestTrait"},{"location":"test-suite/#testing-middleware","text":"The TestRequestHandler helps making it easy to test middleware in a consistent manner. public function testMiddleware(): void { $handler = new TestRequestHandler(new FooMiddleware(), new Response()) $response = $handler->dispatch( new ServerRequest('GET', '/')); // Do your checks } There is also a beforeHandle method which accepts a callback , here you can do prechecks $handler = new TestRequestHandler(new FooMiddleware(), new Response()) $handler->beforeHandle(function(ServerRequestInterface $request) use ($object){ $this->assertTrue($object->wasCalled()); }); $handler->dispatch(new ServerRequest('GET', '/')); You can also get the ServerRequestInterface object that was passed to the handle method, this is useful in situations where Middleware is modifying the request object. $handler->dispatch(new ServerRequest('GET', '/')); $this->assertEquals('bar',$handler->getRequest()->getAttribute('foo'));","title":"Testing Middleware"},{"location":"translator/","text":"Translator The Translator component provides an object that can be passed around your application to translate messages into different languages using the ICU message formatter. It also supports simple message formatting. Usage Create the Translator object and add to your DI container and configure the object in your Middleware or Controller . $bundleFactory = new ResourceBundleFactory(__DIR__ . '/resources/app'); $translator = new Translator($bundleFactory, 'en_US'); Create your translation file return [ 'Hello {user}!' => '\u00a1Hola {user}!' 'Hello world!' => '\u00a1Hola Mundo!', 'You have {count} messages' => 'Tienes {count} mensaje(s)' ]; The Translator uses ICU message format, but also provides a custom pluralazation engine if you dont want or need to use the ICU message format syntax. To translate a message $message = $translator->translate('Hello {user}!', ['user'=> $user->name]); // Hallo Jim Many languages only have two plural forms such as English, then Chinese and Japanses only has one plural form, slavic langauges have 3 or more forms and arabic and a few other languages have 6 or more. If you are not using the ICU message format syntax, you can provide the different plural forms and seeperating with a | , and pass a key called count . When the string is split, if the index is found for the count it will use that, if not it will use the last index. $message = $translator->translate('There are zero apples|There is 1 apple|There are {count} apples', ['count'=> count($apples)]); To change the locale run the folloing method, if you try to set a locale which does not exist, then it will use the default locale which was set when creating the Translator object. $translator->setLocale('en_GB'); You can also get a new instance of the Translator object with a different locale. $spanishTranslator = $translator->withLocale('es_ES'); The translator will always return a message, if no message is found it will return the original message sent. Translator Middlewares The translator middlewares help configuring the Translator object per request. Locale Detector The LocaleDetector attempts to detect the locale from the request headers and will set the locale attribute on the PSR 7 server request object. $middleware = new LocaleDetectorMiddleware('en_US'); // provide a default locale You can also supply a second argument of allowed locales $middleware = new LocaleDetectorMiddleware('en_US', ['en_US','en_GB','es_MX','es_ES']); Locale Setter The LocaleSetterMiddleware quite simply sets the locale on the Translator using if the PSR 7 server request object has the locale attribute set. This allows you to use this when routing, where you want to take the locale from the url e.g. /blog/en/some-post or if you want to detect from the request headers or even maybe the session. $translator = $container->get(TranslatorInterface::class); $middleware = new LocaleSetterMiddleware($translator); Translate Function For those who can't live without the __ function, set the Translator object in the TranslatorManager then call the funtion. use function Lightning\\Translator\\__; TranslatorManager::set($translator); echo __('Hello world!');","title":"Translator"},{"location":"translator/#translator","text":"The Translator component provides an object that can be passed around your application to translate messages into different languages using the ICU message formatter. It also supports simple message formatting.","title":"Translator"},{"location":"translator/#usage","text":"Create the Translator object and add to your DI container and configure the object in your Middleware or Controller . $bundleFactory = new ResourceBundleFactory(__DIR__ . '/resources/app'); $translator = new Translator($bundleFactory, 'en_US'); Create your translation file return [ 'Hello {user}!' => '\u00a1Hola {user}!' 'Hello world!' => '\u00a1Hola Mundo!', 'You have {count} messages' => 'Tienes {count} mensaje(s)' ]; The Translator uses ICU message format, but also provides a custom pluralazation engine if you dont want or need to use the ICU message format syntax. To translate a message $message = $translator->translate('Hello {user}!', ['user'=> $user->name]); // Hallo Jim Many languages only have two plural forms such as English, then Chinese and Japanses only has one plural form, slavic langauges have 3 or more forms and arabic and a few other languages have 6 or more. If you are not using the ICU message format syntax, you can provide the different plural forms and seeperating with a | , and pass a key called count . When the string is split, if the index is found for the count it will use that, if not it will use the last index. $message = $translator->translate('There are zero apples|There is 1 apple|There are {count} apples', ['count'=> count($apples)]); To change the locale run the folloing method, if you try to set a locale which does not exist, then it will use the default locale which was set when creating the Translator object. $translator->setLocale('en_GB'); You can also get a new instance of the Translator object with a different locale. $spanishTranslator = $translator->withLocale('es_ES'); The translator will always return a message, if no message is found it will return the original message sent.","title":"Usage"},{"location":"translator/#translator-middlewares","text":"The translator middlewares help configuring the Translator object per request.","title":"Translator Middlewares"},{"location":"translator/#locale-detector","text":"The LocaleDetector attempts to detect the locale from the request headers and will set the locale attribute on the PSR 7 server request object. $middleware = new LocaleDetectorMiddleware('en_US'); // provide a default locale You can also supply a second argument of allowed locales $middleware = new LocaleDetectorMiddleware('en_US', ['en_US','en_GB','es_MX','es_ES']);","title":"Locale Detector"},{"location":"translator/#locale-setter","text":"The LocaleSetterMiddleware quite simply sets the locale on the Translator using if the PSR 7 server request object has the locale attribute set. This allows you to use this when routing, where you want to take the locale from the url e.g. /blog/en/some-post or if you want to detect from the request headers or even maybe the session. $translator = $container->get(TranslatorInterface::class); $middleware = new LocaleSetterMiddleware($translator);","title":"Locale Setter"},{"location":"translator/#translate-function","text":"For those who can't live without the __ function, set the Translator object in the TranslatorManager then call the funtion. use function Lightning\\Translator\\__; TranslatorManager::set($translator); echo __('Hello world!');","title":"Translate Function"},{"location":"utilities/","text":"Utilities A collection of utility components Collection The collection is a super charged object oriented array, with the main array based functions for sorting and maniupation. $entity = new UserEntity(); $collection = new Collection(); $collection->add($entity); $collection->remove($entity); $key = $collection->indexOf($entity); $bool = $collection->contains($entity); $first = $collection->get(); // Gets the first available element $element = $collection->get(5); // gets by key $bool = $collection->keyExists('foo'); $bool = $collection->isEmpty(); $count = $collection->count(); $collection->clear(); # Sorting $collection->sort(); // sorts the collection by key $collection->sort(fn(UserEntity $user) => $user->getId()); $collection->reverse(); // reverses the order the collection is in $collection->min(); $collection->min(fn(UserEntity $user) => $user->getAge()) $collection->max(); $collection->max(fn(UserEntity $user) => $user->getAge()) # Extracting $collection->slice(0,5); // slice a collection into a new collection $collection->chunk(10); // chunks the collection into an array of collections $collection->keys(); // returns just the keys $collection->values(); // returns just the values of the elements $collection->toArray(); # For each $collection->each(function($contact){ $this->log($contact->name); })->toArray(); # Map $collection->map(fn(UserEntity $user) => $user->getId()); # Reduce $collection->reduce(function ($carry, $value) { return $carry + $value; }); // 6 $collection->reduce(function ($entities, $entity) { $entities[$entity->getId()] = $entity; return $entities; }, $initialValue); // use reduce to indexBy # Filter $collection->filter(fn(UserEntity $user) => $user->getStatus() === 'active'); RandomString A secure random string generator, with various character set constants such as hex, base36, base58, base62, base64, base64 url safe and numeric. Use this to securely generate tokens, passwords, keys, salts etc. $randomString = new RandomString(); // the default character set is set Base 62 $randomString->generate(12); // 7nH3XfBYZG5E $randomString ->withCharset(Randomstring::HEX) ->generate(32); // 9cee331c6104f9035e57259ec13f7d98 $randomString ->withCharset('foobar') ->generate(8); // aaborrro $randomString ->withCharset(RandomString::BASE_62 . RandomString::SPECIAL) ->generate(32); // 86^PY)f$T06x#KJO $randomString ->withCharset(Randomstring::BASE_64_SAFE) ->generate(24); //Go6-dQapORAGBkmY1UQ0eT53 UUID A simple RFC-4122 compliant UUID v4 generator $uuid = (new Uuid())->generate(); // 57519f4b-7f7e-4ceb-ae80-a139dc6f07e9 There is also a preconfigured constant for matching regular expressions $this->assertMatchesRegularExpression(Uuid::PATTERN, $uuid);","title":"Utilities"},{"location":"utilities/#utilities","text":"A collection of utility components","title":"Utilities"},{"location":"utilities/#collection","text":"The collection is a super charged object oriented array, with the main array based functions for sorting and maniupation. $entity = new UserEntity(); $collection = new Collection(); $collection->add($entity); $collection->remove($entity); $key = $collection->indexOf($entity); $bool = $collection->contains($entity); $first = $collection->get(); // Gets the first available element $element = $collection->get(5); // gets by key $bool = $collection->keyExists('foo'); $bool = $collection->isEmpty(); $count = $collection->count(); $collection->clear(); # Sorting $collection->sort(); // sorts the collection by key $collection->sort(fn(UserEntity $user) => $user->getId()); $collection->reverse(); // reverses the order the collection is in $collection->min(); $collection->min(fn(UserEntity $user) => $user->getAge()) $collection->max(); $collection->max(fn(UserEntity $user) => $user->getAge()) # Extracting $collection->slice(0,5); // slice a collection into a new collection $collection->chunk(10); // chunks the collection into an array of collections $collection->keys(); // returns just the keys $collection->values(); // returns just the values of the elements $collection->toArray(); # For each $collection->each(function($contact){ $this->log($contact->name); })->toArray(); # Map $collection->map(fn(UserEntity $user) => $user->getId()); # Reduce $collection->reduce(function ($carry, $value) { return $carry + $value; }); // 6 $collection->reduce(function ($entities, $entity) { $entities[$entity->getId()] = $entity; return $entities; }, $initialValue); // use reduce to indexBy # Filter $collection->filter(fn(UserEntity $user) => $user->getStatus() === 'active');","title":"Collection"},{"location":"utilities/#randomstring","text":"A secure random string generator, with various character set constants such as hex, base36, base58, base62, base64, base64 url safe and numeric. Use this to securely generate tokens, passwords, keys, salts etc. $randomString = new RandomString(); // the default character set is set Base 62 $randomString->generate(12); // 7nH3XfBYZG5E $randomString ->withCharset(Randomstring::HEX) ->generate(32); // 9cee331c6104f9035e57259ec13f7d98 $randomString ->withCharset('foobar') ->generate(8); // aaborrro $randomString ->withCharset(RandomString::BASE_62 . RandomString::SPECIAL) ->generate(32); // 86^PY)f$T06x#KJO $randomString ->withCharset(Randomstring::BASE_64_SAFE) ->generate(24); //Go6-dQapORAGBkmY1UQ0eT53","title":"RandomString"},{"location":"utilities/#uuid","text":"A simple RFC-4122 compliant UUID v4 generator $uuid = (new Uuid())->generate(); // 57519f4b-7f7e-4ceb-ae80-a139dc6f07e9 There is also a preconfigured constant for matching regular expressions $this->assertMatchesRegularExpression(Uuid::PATTERN, $uuid);","title":"UUID"},{"location":"validator/","text":"Validator Create a class extending Validator and configure the validation rules in the initialize method. class UserValidator extends Validator { protected function initialize() : void { $this->createRuleFor('id') ->optional() ->integer() ->lengthBetween(5,11) $this->createRuleFor('email') ->notBlank() ->email() ->lengthBetween(5,255); $this->createRuleFor('password') ->notBlank() ->regularExpression('/^\\S*(?=\\S{8,})(?=\\S*[a-z])(?=\\S*[A-Z])(?=\\S*[\\d])\\S*$/'); ->method('confirm') ->lengthBetween(8,255); } public function confirm(mixed $password, array $data) : bool { return is_string($password) && isset($data['password_confirm']) && $password === $data['password_confirm']; } } Create the validator object $validator = new UserValidator(); To validate a an array of data // validate an array $result = $validator->validate($_POST); // You can also validate value objects $validator->validate(new UserEntity()); // validate PSR Server Request object $validator->validate($serverRequest); You can also just use the Validator as a generic validator. $validator = new Validator(); $validator->createRuleFor('email') ->notBlank() ->email() ->lengthBetween(5,255); $validator->validate($_POST); Validation rules alpha alphaNumeric notNull notEmpty notBlank email in notIn length lengthBetween minLength maxLength greaterThanOrEqualTo greaterThan lessThanOrEqualTo lessThan equalTo notEqualTo range integer string numeric decimal array date (format) datetime (format) time (format) before (date) after (date) Special rules optional If data is empty validation rules are skipped for that field/property. stopOnFailure - Any validation rule will immediately stop running any subsequent rules, calling this will ensure that only one error is every returned. stopIfFailure - If there are any validation errors for this field/property, then stop, do not run anymore validation rules. For example, if you are validating DNS records for a domain, but its an invalid domain, then there is no point checking the DNS records. Errors Object To work with the Errors object $bool = $errors->hasErrors(); $bool = $errors->hasErrors('email'); $array = $errors->getErrors(); $array = $errors->getErrors('email'); $message = $errors->getError('email'); // get the first error $errors->setError('email','invalid email address');","title":"Validator"},{"location":"validator/#validator","text":"Create a class extending Validator and configure the validation rules in the initialize method. class UserValidator extends Validator { protected function initialize() : void { $this->createRuleFor('id') ->optional() ->integer() ->lengthBetween(5,11) $this->createRuleFor('email') ->notBlank() ->email() ->lengthBetween(5,255); $this->createRuleFor('password') ->notBlank() ->regularExpression('/^\\S*(?=\\S{8,})(?=\\S*[a-z])(?=\\S*[A-Z])(?=\\S*[\\d])\\S*$/'); ->method('confirm') ->lengthBetween(8,255); } public function confirm(mixed $password, array $data) : bool { return is_string($password) && isset($data['password_confirm']) && $password === $data['password_confirm']; } } Create the validator object $validator = new UserValidator(); To validate a an array of data // validate an array $result = $validator->validate($_POST); // You can also validate value objects $validator->validate(new UserEntity()); // validate PSR Server Request object $validator->validate($serverRequest); You can also just use the Validator as a generic validator. $validator = new Validator(); $validator->createRuleFor('email') ->notBlank() ->email() ->lengthBetween(5,255); $validator->validate($_POST);","title":"Validator"},{"location":"validator/#validation-rules","text":"alpha alphaNumeric notNull notEmpty notBlank email in notIn length lengthBetween minLength maxLength greaterThanOrEqualTo greaterThan lessThanOrEqualTo lessThan equalTo notEqualTo range integer string numeric decimal array date (format) datetime (format) time (format) before (date) after (date) Special rules optional If data is empty validation rules are skipped for that field/property. stopOnFailure - Any validation rule will immediately stop running any subsequent rules, calling this will ensure that only one error is every returned. stopIfFailure - If there are any validation errors for this field/property, then stop, do not run anymore validation rules. For example, if you are validating DNS records for a domain, but its an invalid domain, then there is no point checking the DNS records.","title":"Validation rules"},{"location":"validator/#errors-object","text":"To work with the Errors object $bool = $errors->hasErrors(); $bool = $errors->hasErrors('email'); $array = $errors->getErrors(); $array = $errors->getErrors('email'); $message = $errors->getError('email'); // get the first error $errors->setError('email','invalid email address');","title":"Errors Object"},{"location":"worker/","text":"Worker The Worker component uses the MessageQueue component to defer execution of tasks. Queue Worker Command The QueueWorkerCommand consumes messages from the MessageQueue and processes jobs that implement RunableInterface . The QueueWorkerCommand to works a specific queue. Create a file bin/queue-worker and run chmod +x on it. #!/usr/bin/env php <?php namespace App\\Command; use Lightning\\Logger\\Logger; use Lightning\\Console\\ConsoleIo; use Lightning\\Worker\\MessageListener; use Lightning\\MessageQueue\\MessageConsumer; use Lightning\\MessageQueue\\MessageProducer; use Lightning\\Console\\ConsoleArgumentParser; use Lightning\\Logger\\Handler\\ConsoleHandler; use Lightning\\MessageQueue\\RedisMessageQueue; use Lightning\\Worker\\Command\\QueueWorkerCommand; include dirname(__DIR__) . '/config/bootstrap_cli.php'; // Create the Message Queue $redis = new \\Redis(); $redis->pconnect('redis', 6379); $messageQueue = new RedisMessageQueue($redis); // Create and configure the Message Consumer $consumer = new MessageConsumer($messageQueue, 'default'); $messageListener = new MessageListener(new MessageProducer($messageQueue), $consumer); $consumer->setMessageListener($messageListener); // Create the PSR-3: Logger $logger = new Logger('queue'); $logger->addHandler(new ConsoleHandler()); $messageListener->setLogger($logger); $command = new QueueWorkerCommand(new ConsoleArgumentParser(), new ConsoleIo(), $consumer); exit($command->run($argv)); Now when you execute a worker for a particular queue root@32ec5221b471:/var/www# bin/queue-worker mailers -d [2022-07-04 8:40:00] queue DEBUG: App\\Command\\SendEmailNotification received [2022-07-04 8:40:00] queue ERROR: App\\Command\\SendEmailNotification could not connect to SMTP server [2022-07-04 8:50:00] queue DEBUG: App\\Command\\SendEmailNotification received [2022-07-04 8:50:00] queue INFO: App\\Command\\SendEmailNotification executed Job The AbstractJob class gives you everything you need to run a background job class SendEmailNotification extends AbstractJob { // number of times to retry if exception thrown protected int $maxRetries = 3; // delay in seconds between retries protected int $delay = 5; /** * Use DI here */ public function __construct(protected Mailer $mailer) { } protected function initialize() : void { } protected function execute(Params $params): void { $this->mailer->send('welcome-email', $params->get('email')); } } Then create the Job and send this using the MessageProducer $job = new SendEmailNotification($mailer); $job = $job->withParameters(['email'=>'jon@example.com']); (new MessageProducer(new MemoryQueue()))->send('mailers', $job); When you execute the QueueWorkerCommand the job will be executed.","title":"Worker"},{"location":"worker/#worker","text":"The Worker component uses the MessageQueue component to defer execution of tasks.","title":"Worker"},{"location":"worker/#queue-worker-command","text":"The QueueWorkerCommand consumes messages from the MessageQueue and processes jobs that implement RunableInterface . The QueueWorkerCommand to works a specific queue. Create a file bin/queue-worker and run chmod +x on it. #!/usr/bin/env php <?php namespace App\\Command; use Lightning\\Logger\\Logger; use Lightning\\Console\\ConsoleIo; use Lightning\\Worker\\MessageListener; use Lightning\\MessageQueue\\MessageConsumer; use Lightning\\MessageQueue\\MessageProducer; use Lightning\\Console\\ConsoleArgumentParser; use Lightning\\Logger\\Handler\\ConsoleHandler; use Lightning\\MessageQueue\\RedisMessageQueue; use Lightning\\Worker\\Command\\QueueWorkerCommand; include dirname(__DIR__) . '/config/bootstrap_cli.php'; // Create the Message Queue $redis = new \\Redis(); $redis->pconnect('redis', 6379); $messageQueue = new RedisMessageQueue($redis); // Create and configure the Message Consumer $consumer = new MessageConsumer($messageQueue, 'default'); $messageListener = new MessageListener(new MessageProducer($messageQueue), $consumer); $consumer->setMessageListener($messageListener); // Create the PSR-3: Logger $logger = new Logger('queue'); $logger->addHandler(new ConsoleHandler()); $messageListener->setLogger($logger); $command = new QueueWorkerCommand(new ConsoleArgumentParser(), new ConsoleIo(), $consumer); exit($command->run($argv)); Now when you execute a worker for a particular queue root@32ec5221b471:/var/www# bin/queue-worker mailers -d [2022-07-04 8:40:00] queue DEBUG: App\\Command\\SendEmailNotification received [2022-07-04 8:40:00] queue ERROR: App\\Command\\SendEmailNotification could not connect to SMTP server [2022-07-04 8:50:00] queue DEBUG: App\\Command\\SendEmailNotification received [2022-07-04 8:50:00] queue INFO: App\\Command\\SendEmailNotification executed","title":"Queue Worker Command"},{"location":"worker/#job","text":"The AbstractJob class gives you everything you need to run a background job class SendEmailNotification extends AbstractJob { // number of times to retry if exception thrown protected int $maxRetries = 3; // delay in seconds between retries protected int $delay = 5; /** * Use DI here */ public function __construct(protected Mailer $mailer) { } protected function initialize() : void { } protected function execute(Params $params): void { $this->mailer->send('welcome-email', $params->get('email')); } } Then create the Job and send this using the MessageProducer $job = new SendEmailNotification($mailer); $job = $job->withParameters(['email'=>'jon@example.com']); (new MessageProducer(new MemoryQueue()))->send('mailers', $job); When you execute the QueueWorkerCommand the job will be executed.","title":"Job"},{"location":"http/authentication/","text":"Authentication The Authentication package provides middleware components for authentication and authorization Identity Service The identity service is for handling the user details lookup, you can use the PdoIdentityService or attach the IdentityServiceInterface to your existing repository or create your own identity service which may use a different storage type. $identityService = (new PdoIdentityService($container->get(PDO::class))) ->setTable('identities') // database table name ->setIdentifierName('username'); // the name/column for the identifier, e.g. username, email , token etc ->setCredentialName('password'); // this is the password name/column e.g. password, hashed_password Password Hashers We provide Argon2 and Bcrypt password hashers, and the PasswordHasherInterface so you can create a custom passwoder hasher. OWSAP recommends to use Argon2 ,and if that is not available then Bcrypt. See OWASP Password Storage Cheat Sheet Middlewares Some of the authentication middlewares will return a response, therefore for those ones you will need to provide an empty PSR-7 Response object. Login Form The FormAuthenticationMiddleware is for managing authentication and authorization for web applications using a login form, once the user logs in, the user details are stored in session under the identity key. $identityService = $container->get(IdentityServiceInterface::class); $session = $container->get(SessionInterface::class); $middleware (new FormAuthenticationMiddleware($identityService, new BcryptPasswordHasher(), $session, new ResponseFactory())) ->setLoginPath('/login') ->setUsernameField('email') ->setPasswordField('password'); The LoginFormAuthentication allows the login path request to be displayed, and will only accept credentials that are sent by a POST request to the loginPath . $middleware->setLoginPath('/login'); Here is what it might look like in the controller. public function login(ServerRequestInterface $request): ResponseInterface { if ($request->getMethod() === 'POST') { // user is now logged in if($identity = $request->getAttribute('identity')){ return $this->redirect('/articles/index'); } } return $this->render('/login'); } public function logout(SessionInterface $session): ResponseInterface { $session->clear(); $session->regenerateId(); return $this->redirect('/login'); } By default an UnauthorizedException is thrown if the user tries to access a resource that requires authentication, however if you want them to redirect to another page, then you will need to set the unauthenticated redirect. $middleware->setUnauthenticatedRedirect('/login'); Token Authentication The TokenAuthenticationMiddleware allows you authenticate using an API token either in the URL query param or a header To use a query param e.g. /api/status?token=xxxxx (new TokenAuthenticationMiddleware($container->get(IdentityServiceInterface::class))) ->setQueryParam('token'); To search for the token in the headers (new TokenAuthenticationMiddleware($container->get(IdentityServiceInterface::class))) ->setHeader('X-API-Token') HTTP Basic Authentication (BA) The HttpBasicAuthenticationMiddleware provides a method for the user to provide a username and password to access a resource, this should only be used with HTTPS. $autenticationMiddleware = new HttpBasicAuthenticationMiddleware( $container->get(IdentityServiceInterface::class), new BcryptPasswordHasher(), new ResponseFactory() ); ``` By default if the resource is protected and user has not authenticated, it will challenge the user for a username and password, if you prefer to throw an exception, then disable the challenge. ```php $autenticationMiddleware->disableChallenge(); ## Authentication Middleware Settings All authentication middlewares have the following shared methods: Public paths To make some urls public, and therefore dont require any authentication $middleware->setPublicPaths([ '/status', '/about' ]); Area specific path You can also lock down specific parts of your web application, such as an admin section. $middleware->setPath('/admin');","title":"Authentication"},{"location":"http/authentication/#authentication","text":"The Authentication package provides middleware components for authentication and authorization","title":"Authentication"},{"location":"http/authentication/#identity-service","text":"The identity service is for handling the user details lookup, you can use the PdoIdentityService or attach the IdentityServiceInterface to your existing repository or create your own identity service which may use a different storage type. $identityService = (new PdoIdentityService($container->get(PDO::class))) ->setTable('identities') // database table name ->setIdentifierName('username'); // the name/column for the identifier, e.g. username, email , token etc ->setCredentialName('password'); // this is the password name/column e.g. password, hashed_password","title":"Identity Service"},{"location":"http/authentication/#password-hashers","text":"We provide Argon2 and Bcrypt password hashers, and the PasswordHasherInterface so you can create a custom passwoder hasher. OWSAP recommends to use Argon2 ,and if that is not available then Bcrypt. See OWASP Password Storage Cheat Sheet","title":"Password Hashers"},{"location":"http/authentication/#middlewares","text":"Some of the authentication middlewares will return a response, therefore for those ones you will need to provide an empty PSR-7 Response object.","title":"Middlewares"},{"location":"http/authentication/#login-form","text":"The FormAuthenticationMiddleware is for managing authentication and authorization for web applications using a login form, once the user logs in, the user details are stored in session under the identity key. $identityService = $container->get(IdentityServiceInterface::class); $session = $container->get(SessionInterface::class); $middleware (new FormAuthenticationMiddleware($identityService, new BcryptPasswordHasher(), $session, new ResponseFactory())) ->setLoginPath('/login') ->setUsernameField('email') ->setPasswordField('password'); The LoginFormAuthentication allows the login path request to be displayed, and will only accept credentials that are sent by a POST request to the loginPath . $middleware->setLoginPath('/login'); Here is what it might look like in the controller. public function login(ServerRequestInterface $request): ResponseInterface { if ($request->getMethod() === 'POST') { // user is now logged in if($identity = $request->getAttribute('identity')){ return $this->redirect('/articles/index'); } } return $this->render('/login'); } public function logout(SessionInterface $session): ResponseInterface { $session->clear(); $session->regenerateId(); return $this->redirect('/login'); } By default an UnauthorizedException is thrown if the user tries to access a resource that requires authentication, however if you want them to redirect to another page, then you will need to set the unauthenticated redirect. $middleware->setUnauthenticatedRedirect('/login');","title":"Login Form"},{"location":"http/authentication/#token-authentication","text":"The TokenAuthenticationMiddleware allows you authenticate using an API token either in the URL query param or a header To use a query param e.g. /api/status?token=xxxxx (new TokenAuthenticationMiddleware($container->get(IdentityServiceInterface::class))) ->setQueryParam('token'); To search for the token in the headers (new TokenAuthenticationMiddleware($container->get(IdentityServiceInterface::class))) ->setHeader('X-API-Token')","title":"Token Authentication"},{"location":"http/authentication/#http-basic-authentication-ba","text":"The HttpBasicAuthenticationMiddleware provides a method for the user to provide a username and password to access a resource, this should only be used with HTTPS. $autenticationMiddleware = new HttpBasicAuthenticationMiddleware( $container->get(IdentityServiceInterface::class), new BcryptPasswordHasher(), new ResponseFactory() ); ``` By default if the resource is protected and user has not authenticated, it will challenge the user for a username and password, if you prefer to throw an exception, then disable the challenge. ```php $autenticationMiddleware->disableChallenge(); ## Authentication Middleware Settings All authentication middlewares have the following shared methods:","title":"HTTP Basic Authentication (BA)"},{"location":"http/authentication/#public-paths","text":"To make some urls public, and therefore dont require any authentication $middleware->setPublicPaths([ '/status', '/about' ]);","title":"Public paths"},{"location":"http/authentication/#area-specific-path","text":"You can also lock down specific parts of your web application, such as an admin section. $middleware->setPath('/admin');","title":"Area specific path"},{"location":"http/cookie/","text":"Cookie Cookie Object A Cookie object can be created like this, the default path is / and the default max age is 0 which means until the browser is closed. $cookie = new Cookie('foo','bar'); Setter methods $cookie->setMaxAge(3600); // Default for cookie is 0 $cookie->setHttpOnly(true); $cookie->setSecure(true); $cookie->setPath('/articles/'); $cookie->setDomain('example.com') $cookie->setSameSite('Lax'); // to add the cookie to a Response object $response = $cookie->addToResponse($response); Cookies The Cookies object helps reading cookies from the request and writing to the response. $cookies = new Cookies(); $cookies->setServerRequest($request); // Sets the Request object, cookies will be read from here $result = $cookies->has('foo'); $value = $cookies->get('foo'); // to add a cookie which later will be added to the Response $cookie = new Cookie('bar','1234'); $cookie->setMaxAge(3600); $cookies->add($cookie); // To delete a cookie pass a cookie with the name $cookies->delete(new Cookie('bar')); $response = $cookies->addToResponse($response); CookieMiddleware The Cookies object will be attached to the ServerRequest $cookies = new Cookies(); $middleware = new CookieMiddleware($cookies); $cookies = $request->getAttribute('cookies'); If you are using DI (dependency injection), then make sure that you use the same instance $cookies = $container->get(Cookies::class); $middleware = new CookieMiddleware($cookies);","title":"Cookie"},{"location":"http/cookie/#cookie","text":"","title":"Cookie"},{"location":"http/cookie/#cookie-object","text":"A Cookie object can be created like this, the default path is / and the default max age is 0 which means until the browser is closed. $cookie = new Cookie('foo','bar'); Setter methods $cookie->setMaxAge(3600); // Default for cookie is 0 $cookie->setHttpOnly(true); $cookie->setSecure(true); $cookie->setPath('/articles/'); $cookie->setDomain('example.com') $cookie->setSameSite('Lax'); // to add the cookie to a Response object $response = $cookie->addToResponse($response);","title":"Cookie Object"},{"location":"http/cookie/#cookies","text":"The Cookies object helps reading cookies from the request and writing to the response. $cookies = new Cookies(); $cookies->setServerRequest($request); // Sets the Request object, cookies will be read from here $result = $cookies->has('foo'); $value = $cookies->get('foo'); // to add a cookie which later will be added to the Response $cookie = new Cookie('bar','1234'); $cookie->setMaxAge(3600); $cookies->add($cookie); // To delete a cookie pass a cookie with the name $cookies->delete(new Cookie('bar')); $response = $cookies->addToResponse($response);","title":"Cookies"},{"location":"http/cookie/#cookiemiddleware","text":"The Cookies object will be attached to the ServerRequest $cookies = new Cookies(); $middleware = new CookieMiddleware($cookies); $cookies = $request->getAttribute('cookies'); If you are using DI (dependency injection), then make sure that you use the same instance $cookies = $container->get(Cookies::class); $middleware = new CookieMiddleware($cookies);","title":"CookieMiddleware"},{"location":"http/emitter/","text":"Response Emitter (todo)","title":"Emitter"},{"location":"http/emitter/#response-emitter-todo","text":"","title":"Response Emitter  (todo)"},{"location":"http/exception-handler/","text":"PSR-15 Exception Handler The PSR-15 recommends that exceptions are caught and returned as a Response using a middleware component which is executed at the start. Usage Create the Middleware by passing a path to the error files , the ErrorRenderer object, a PSR-17 Response Factory and optionally a PSR-3 Logger and add this as the first middleware to the stack. $middleware = new ExceptionHandlerMiddleware( __DIR__ . '/../app/View/error' , new ErrorRenderer(), new ResponseFactory(), new Logger() ); Any Lighting\\Http\\Exceptions\\HttpException exceptions will show the exception message and status code that was passed, all other exceptions will be treated as an internal server error with the generic message Internal Server Error . HTTP exceptions are designed to be showed to the user, whilst other exception messages are not. HTML Rendering You must have two files error400.php or error500.php will be rendered, code , message , request and exception vars will be passed to these. See below for a template. JSON If the request header accepts application/json then the exception will be rendered as JSON. { \"error\": { \"code\": 500, \"message\": \"Internal Server Error\" } } XML If the request header accepts text/xml or application/xml then the exception will be rendered as XML. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <error> <code>500</code> <message>Internal Server Error</message> </error> Error Handling There is also a simple ErrorHandler class that will convert all errors to exceptions which you can add to your bootstrap process. error_reporting(E_ALL); (new ErrorHandler())->register(); Example Template Here is an example for error400.php <!doctype html> <html lang=\"en\"> <head> <meta charset=\"utf-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"> <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-KyZXEAg3QhqLMpG8r+8fhAXLRk2vvoC2f3B09zVXn8CA5QIVfZOJ3BCsw2P0p/We\" crossorigin=\"anonymous\"> <title><?= $code ?> - <?= $message ?></title> <style> html, body { height: 100% } body { margin: 0; padding: 20px; background-color: #FFC900; } .block span, .block p { font-weight: 700; color: #fff; } </style> </head> <body> <div class=\"h-100 row align-items-center\"> <div class=\"block col-md-12 text-center\"> <span class=\"display-1 d-block\"><?= $code ?></span> <div class=\"mb-4 lead\"> <p><?= $message ?></p> </div> </div> </div> </body> </html> Resources https://www.php-fig.org/psr/psr-3/ https://www.php-fig.org/psr/psr-15/ https://www.php-fig.org/psr/psr-17/","title":"ExceptionHandler"},{"location":"http/exception-handler/#psr-15-exception-handler","text":"The PSR-15 recommends that exceptions are caught and returned as a Response using a middleware component which is executed at the start.","title":"PSR-15 Exception Handler"},{"location":"http/exception-handler/#usage","text":"Create the Middleware by passing a path to the error files , the ErrorRenderer object, a PSR-17 Response Factory and optionally a PSR-3 Logger and add this as the first middleware to the stack. $middleware = new ExceptionHandlerMiddleware( __DIR__ . '/../app/View/error' , new ErrorRenderer(), new ResponseFactory(), new Logger() ); Any Lighting\\Http\\Exceptions\\HttpException exceptions will show the exception message and status code that was passed, all other exceptions will be treated as an internal server error with the generic message Internal Server Error . HTTP exceptions are designed to be showed to the user, whilst other exception messages are not.","title":"Usage"},{"location":"http/exception-handler/#html-rendering","text":"You must have two files error400.php or error500.php will be rendered, code , message , request and exception vars will be passed to these. See below for a template.","title":"HTML Rendering"},{"location":"http/exception-handler/#json","text":"If the request header accepts application/json then the exception will be rendered as JSON. { \"error\": { \"code\": 500, \"message\": \"Internal Server Error\" } }","title":"JSON"},{"location":"http/exception-handler/#xml","text":"If the request header accepts text/xml or application/xml then the exception will be rendered as XML. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <error> <code>500</code> <message>Internal Server Error</message> </error>","title":"XML"},{"location":"http/exception-handler/#error-handling","text":"There is also a simple ErrorHandler class that will convert all errors to exceptions which you can add to your bootstrap process. error_reporting(E_ALL); (new ErrorHandler())->register();","title":"Error Handling"},{"location":"http/exception-handler/#example-template","text":"Here is an example for error400.php <!doctype html> <html lang=\"en\"> <head> <meta charset=\"utf-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"> <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-KyZXEAg3QhqLMpG8r+8fhAXLRk2vvoC2f3B09zVXn8CA5QIVfZOJ3BCsw2P0p/We\" crossorigin=\"anonymous\"> <title><?= $code ?> - <?= $message ?></title> <style> html, body { height: 100% } body { margin: 0; padding: 20px; background-color: #FFC900; } .block span, .block p { font-weight: 700; color: #fff; } </style> </head> <body> <div class=\"h-100 row align-items-center\"> <div class=\"block col-md-12 text-center\"> <span class=\"display-1 d-block\"><?= $code ?></span> <div class=\"mb-4 lead\"> <p><?= $message ?></p> </div> </div> </div> </body> </html>","title":"Example Template"},{"location":"http/exception-handler/#resources","text":"https://www.php-fig.org/psr/psr-3/ https://www.php-fig.org/psr/psr-15/ https://www.php-fig.org/psr/psr-17/","title":"Resources"},{"location":"http/exception/","text":"Http Exception A set of ready made reusuable Exceptions for HTTP applications Create any HTTP exception throw new HttpException('Proxy Authentication Required', 407); Use on of the ready made throw new BadRequest(); throw new BadRequest('You need to supply the API token');","title":"Exception"},{"location":"http/exception/#http-exception","text":"A set of ready made reusuable Exceptions for HTTP applications Create any HTTP exception throw new HttpException('Proxy Authentication Required', 407); Use on of the ready made throw new BadRequest(); throw new BadRequest('You need to supply the API token');","title":"Http Exception"},{"location":"http/flash/","text":"Flash The Flash component makes it easy to send messages between requests. $session = new PhpSession(); // This will have to be started $session->start(); $flash = new Flash($session); $flash->set('success','Your contact has been saved.'); $bool = $flash->has('success'); $message = $flash->get('success'); $messages = $flash->getMessages(); foreach($flash as $key => $message) { echo $message; }","title":"Flash"},{"location":"http/flash/#flash","text":"The Flash component makes it easy to send messages between requests. $session = new PhpSession(); // This will have to be started $session->start(); $flash = new Flash($session); $flash->set('success','Your contact has been saved.'); $bool = $flash->has('success'); $message = $flash->get('success'); $messages = $flash->getMessages(); foreach($flash as $key => $message) { echo $message; }","title":"Flash"},{"location":"http/middleware/","text":"Middleware CSRF Protection Middleware You should also use SameSite cookie attribute for your session cookies to mitigate CSRF attacks, using the Lax setting gives good balance between usuability and security. This CSRF protection middleware uses the Synchronizer Token Pattern whilst providing a unique token per request (not per session). Using a token per request helps mitigate other types of attacks (e.g BREACH). To create the middleware $middleware = new CsrfProtectionMiddleware($container->get(SessionInterface::class)); The middleware looks for either a header X-CSRF-Token or a csrfToken form field, when a state changing request has been made, for example POST , PATCH , PUT or DELETE . If the token is not provided or the token is not valid a 403 forbidden exception will be thrown. By default 25 tokens are kept at one time, you can increase or decrease this by setting the setting, wether to make it more usuable or more secure. $middleware->setMaxTokens(100); By default a CSRF token can only be used once, if you find this is giving you usability issues you can disable this. $middleware->disableSingleUseTokens(); see the OWASP cross-site request forgery prevention cheat sheet to find out more.","title":"Middleware"},{"location":"http/middleware/#middleware","text":"","title":"Middleware"},{"location":"http/middleware/#csrf-protection-middleware","text":"You should also use SameSite cookie attribute for your session cookies to mitigate CSRF attacks, using the Lax setting gives good balance between usuability and security. This CSRF protection middleware uses the Synchronizer Token Pattern whilst providing a unique token per request (not per session). Using a token per request helps mitigate other types of attacks (e.g BREACH). To create the middleware $middleware = new CsrfProtectionMiddleware($container->get(SessionInterface::class)); The middleware looks for either a header X-CSRF-Token or a csrfToken form field, when a state changing request has been made, for example POST , PATCH , PUT or DELETE . If the token is not provided or the token is not valid a 403 forbidden exception will be thrown. By default 25 tokens are kept at one time, you can increase or decrease this by setting the setting, wether to make it more usuable or more secure. $middleware->setMaxTokens(100); By default a CSRF token can only be used once, if you find this is giving you usability issues you can disable this. $middleware->disableSingleUseTokens(); see the OWASP cross-site request forgery prevention cheat sheet to find out more.","title":"CSRF Protection Middleware"},{"location":"http/session/","text":"Session PSR friendly session.","title":"Session"},{"location":"http/session/#session","text":"PSR friendly session.","title":"Session"}]}